<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: Encoding::Converter [RDoc Documentation]</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }<\/style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">Encoding::Converter</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../../files/encoding_c.html">

                encoding.c

                </a>


        <br />

            </td>
        </tr>


        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>

                <a href="../Data.html">

                Data

               </a>

            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">

  <div id="contextContent">

    <div id="description">
      <p>
call-seq:
</p>
<pre>
  ecerr.incomplete_input?         -&gt; true or false
</pre>
<p>
Returns true if the invalid byte sequence error is caused by premature end
of string.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)

 begin
   ec.convert(&quot;abc\xA1z&quot;)
 rescue Encoding::InvalidByteSequenceError
   p $!      #=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xA1&quot; followed by &quot;z&quot; on EUC-JP&gt;
   p $!.incomplete_input?    #=&gt; false
 end

 begin
   ec.convert(&quot;abc\xA1&quot;)
   ec.finish
 rescue Encoding::InvalidByteSequenceError
   p $!      #=&gt; #&lt;Encoding::InvalidByteSequenceError: incomplete &quot;\xA1&quot; on EUC-JP&gt;
   p $!.incomplete_input?    #=&gt; true
 end
</pre>

    </div>

   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M000561">asciicompat_encoding</a>&nbsp;&nbsp;

        <a href="#M000569">convert</a>&nbsp;&nbsp;

        <a href="#M000565">convpath</a>&nbsp;&nbsp;

        <a href="#M000567">destination_encoding</a>&nbsp;&nbsp;

        <a href="#M000570">finish</a>&nbsp;&nbsp;

        <a href="#M000572">insert_output</a>&nbsp;&nbsp;

        <a href="#M000564">inspect</a>&nbsp;&nbsp;

        <a href="#M000574">last_error</a>&nbsp;&nbsp;

        <a href="#M000563">new</a>&nbsp;&nbsp;

        <a href="#M000568">primitive_convert</a>&nbsp;&nbsp;

        <a href="#M000571">primitive_errinfo</a>&nbsp;&nbsp;

        <a href="#M000573">putback</a>&nbsp;&nbsp;

        <a href="#M000575">replacement</a>&nbsp;&nbsp;

        <a href="#M000576">replacement=</a>&nbsp;&nbsp;

        <a href="#M000562">search_convpath</a>&nbsp;&nbsp;

        <a href="#M000566">source_encoding</a>&nbsp;&nbsp;

      </div>
    </div>

  </div>

    <!-- if includes -->

    <div id="section">

    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">INVALID_MASK</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_INVALID_MASK)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">INVALID_REPLACE</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_INVALID_REPLACE)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">UNDEF_MASK</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_UNDEF_MASK)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">UNDEF_REPLACE</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_UNDEF_REPLACE)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">UNDEF_HEX_CHARREF</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_UNDEF_HEX_CHARREF)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PARTIAL_INPUT</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_PARTIAL_INPUT)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">AFTER_OUTPUT</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_AFTER_OUTPUT)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">UNIVERSAL_NEWLINE_DECORATOR</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_UNIVERSAL_NEWLINE_DECORATOR)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">CRLF_NEWLINE_DECORATOR</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_CRLF_NEWLINE_DECORATOR)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">CR_NEWLINE_DECORATOR</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_CR_NEWLINE_DECORATOR)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">XML_TEXT_DECORATOR</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_XML_TEXT_DECORATOR)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">XML_ATTR_CONTENT_DECORATOR</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_XML_ATTR_CONTENT_DECORATOR)</td>

        </tr>

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">XML_ATTR_QUOTE_DECORATOR</td>
          <td>=</td>
          <td class="context-item-value">INT2FIX(ECONV_XML_ATTR_QUOTE_DECORATOR)</td>

        </tr>

        </table>
      </div>
    </div>




    <!-- if method_list -->

    <div id="methods">

      <h3 class="section-bar">Public Class methods</h3>


      <div id="method-M000561" class="method-detail">
        <a name="M000561"></a>

        <div class="method-heading">

          <a href="Converter.src/M000561.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000561.html');return false;">

          <span class="method-name">Encoding::Converter.asciicompat_encoding(string) => encoding or nil<br />
Encoding::Converter.asciicompat_encoding(encoding) => encoding or nil<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns the corresponding ASCII compatible encoding.
</p>
<p>
Returns nil if the argument is an ASCII compatible encoding.
</p>
<p>
&#8220;corresponding ASCII compatible encoding&#8221; is a ASCII compatible
encoding which can represents exactly the same characters as the given
ASCII incompatible encoding. So, no conversion undefined error occurs when
converting between the two encodings.
</p>
<pre>
  Encoding::Converter.asciicompat_encoding(&quot;ISO-2022-JP&quot;) #=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;
  Encoding::Converter.asciicompat_encoding(&quot;UTF-16BE&quot;) #=&gt; #&lt;Encoding:UTF-8&gt;
  Encoding::Converter.asciicompat_encoding(&quot;UTF-8&quot;) #=&gt; nil
</pre>

        </div>
      </div>


      <div id="method-M000563" class="method-detail">
        <a name="M000563"></a>

        <div class="method-heading">

          <a href="Converter.src/M000563.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000563.html');return false;">

          <span class="method-name">Encoding::Converter.new(source_encoding, destination_encoding)<br />
Encoding::Converter.new(source_encoding, destination_encoding, opt)<br />
Encoding::Converter.new(convpath)<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
possible options elements:
</p>
<pre>
  hash form:
    :invalid =&gt; nil            # raise error on invalid byte sequence (default)
    :invalid =&gt; :replace       # replace invalid byte sequence
    :undef =&gt; nil              # raise error on undefined conversion (default)
    :undef =&gt; :replace         # replace undefined conversion
    :replace =&gt; string         # replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)
    :universal_newline =&gt; true # decorator for converting CRLF and CR to LF
    :crlf_newline =&gt; true      # decorator for converting LF to CRLF
    :cr_newline =&gt; true        # decorator for converting LF to CR
    :xml =&gt; :text              # escape as XML CharData.
    :xml =&gt; :attr              # escape as XML AttValue
  integer form:
    Encoding::Converter::INVALID_REPLACE
    Encoding::Converter::UNDEF_REPLACE
    Encoding::Converter::UNDEF_HEX_CHARREF
    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
    Encoding::Converter::CRLF_NEWLINE_DECORATOR
    Encoding::Converter::CR_NEWLINE_DECORATOR
    Encoding::Converter::XML_TEXT_DECORATOR
    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR
</pre>
<p>
<a href="Converter.html#M000563">Encoding::Converter.new</a> creates an
instance of <a href="Converter.html">Encoding::Converter</a>.
</p>
<p>
Source_encoding and <a
href="Converter.html#M000567">destination_encoding</a> should be a string
or <a href="../Encoding.html">Encoding</a> object.
</p>
<p>
opt should be nil, a hash or an integer.
</p>
<p>
convpath should be an array. convpath may contain
</p>
<ul>
<li>two-element arrays which contain encodings or encoding names, or

</li>
<li>strings representing decorator names.

</li>
</ul>
<p>
<a href="Converter.html#M000563">Encoding::Converter.new</a> optionally
takes an option. The option should be a hash or an integer. The option hash
can contain :invalid => nil, etc. The option integer should be logical-or
of constants such as Encoding::Converter::INVALID_REPLACE, etc.
</p>
<dl>
<dt>:invalid => nil</dt><dd>Raise error on invalid byte sequence. This is a default behavior.

</dd>
<dt>:invalid => :replace</dt><dd>Replace invalid byte sequence by replacement string.

</dd>
<dt>:undef => nil</dt><dd>Raise an error if a character in <a
href="Converter.html#M000566">source_encoding</a> is not defined in
destination_encoding. This is a default behavior.

</dd>
<dt>:undef => :replace</dt><dd>Replace undefined character in <a
href="Converter.html#M000567">destination_encoding</a> with replacement
string.

</dd>
<dt>:replace => string</dt><dd>Specify the replacement string. If not specified, &#8220;uFFFD&#8221; is
used for Unicode encodings and &#8220;?&#8221; for others.

</dd>
<dt>:universal_newline => true</dt><dd>Convert CRLF and CR to LF.

</dd>
<dt>:crlf_newline => true</dt><dd>Convert LF to CRLF.

</dd>
<dt>:cr_newline => true</dt><dd>Convert LF to CR.

</dd>
<dt>:xml => :text</dt><dd>Escape as <a href="../XML.html">XML</a> CharData. This form can be used as
a HTML 4.0 PCDATA.

<ul>
<li>&#8217;&amp;&#8217; -> &#8217;&amp;amp;&#8217;

</li>
<li>&#8217;<&#8217; -> &#8217;&amp;lt;&#8217;

</li>
<li>&#8217;>&#8217; -> &#8217;&amp;gt;&#8217;

</li>
<li>undefined characters in <a
href="Converter.html#M000567">destination_encoding</a> -> hexadecimal
CharRef such as &amp;xHH;

</li>
</ul>
</dd>
<dt>:xml => :attr</dt><dd>Escape as <a href="../XML.html">XML</a> AttValue. The converted result is
quoted as &#8220;&#8230;&#8221;. This form can be used as a HTML 4.0
attribute value.

<ul>
<li>&#8217;&amp;&#8217; -> &#8217;&amp;amp;&#8217;

</li>
<li>&#8217;<&#8217; -> &#8217;&amp;lt;&#8217;

</li>
<li>&#8217;>&#8217; -> &#8217;&amp;gt;&#8217;

</li>
<li>&#8217;&#8221;&#8217; -> &#8217;&amp;quot;&#8217;

</li>
<li>undefined characters in <a
href="Converter.html#M000567">destination_encoding</a> -> hexadecimal
CharRef such as &amp;xHH;

</li>
</ul>
</dd>
</dl>
<p>
Examples:
</p>
<pre>
  # UTF-16BE to UTF-8
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)

  # Usually, decorators such as newline conversion are inserted last.
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;, :universal_newline =&gt; true)
  p ec.convpath #=&gt; [[#&lt;Encoding:UTF-16BE&gt;, #&lt;Encoding:UTF-8&gt;],
                #    &quot;universal_newline&quot;]

  # But, if the last encoding is ASCII incompatible,
  # decorators are inserted before the last conversion.
  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;, :crlf_newline =&gt; true)
  p ec.convpath #=&gt; [&quot;crlf_newline&quot;,
                #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]

  # Conversion path can be specified directly.
  ec = Encoding::Converter.new([&quot;universal_newline&quot;, [&quot;EUC-JP&quot;, &quot;UTF-8&quot;], [&quot;UTF-8&quot;, &quot;UTF-16BE&quot;]])
  p ec.convpath #=&gt; [&quot;universal_newline&quot;,
                #    [#&lt;Encoding:EUC-JP&gt;, #&lt;Encoding:UTF-8&gt;],
                #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]
</pre>

        </div>
      </div>


      <div id="method-M000562" class="method-detail">
        <a name="M000562"></a>

        <div class="method-heading">

          <a href="Converter.src/M000562.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000562.html');return false;">

          <span class="method-name">Encoding::Converter.search_convpath(source_encoding, destination_encoding)         &rarr; ary<br />
Encoding::Converter.search_convpath(source_encoding, destination_encoding, opt)    &rarr; ary<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns a conversion path.
</p>
<pre>
 p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;)
 #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;]]

 p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, universal_newline: true)
 #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
 #    &quot;universal_newline&quot;]

 p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;UTF-32BE&quot;, universal_newline: true)
 #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 #    &quot;universal_newline&quot;,
 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-32BE&gt;]]
</pre>

        </div>
      </div>


      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M000569" class="method-detail">
        <a name="M000569"></a>

        <div class="method-heading">

          <a href="Converter.src/M000569.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000569.html');return false;">

          <span class="method-name">ec.convert(source_string) &rarr; destination_string<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Convert source_string and return destination_string.
</p>
<p>
source_string is assumed as a part of source. i.e. :partial_input=>true is
specified internally. finish method should be used last.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;euc-jp&quot;)
  puts ec.convert(&quot;\u3042&quot;).dump     #=&gt; &quot;\xA4\xA2&quot;
  puts ec.finish.dump                #=&gt; &quot;&quot;

  ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
  puts ec.convert(&quot;\xA4&quot;).dump       #=&gt; &quot;&quot;
  puts ec.convert(&quot;\xA2&quot;).dump       #=&gt; &quot;\xE3\x81\x82&quot;
  puts ec.finish.dump                #=&gt; &quot;&quot;

  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
  puts ec.convert(&quot;\xE3&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.convert(&quot;\x81&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.convert(&quot;\x82&quot;).dump       #=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.finish.dump                #=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
</pre>
<p>
If a conversion error occur, <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
or <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
is raised. <a href="Converter.html#M000569">Encoding::Converter#convert</a>
doesn&#8217;t supply methods to recover or restart from these exceptions.
When you want to handle these conversion errors, use <a
href="Converter.html#M000568">Encoding::Converter#primitive_convert</a>.
</p>

        </div>
      </div>


      <div id="method-M000565" class="method-detail">
        <a name="M000565"></a>

        <div class="method-heading">

          <a href="Converter.src/M000565.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000565.html');return false;">

          <span class="method-name">ec.convpath        &rarr; ary<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns the conversion path of ec.
</p>
<p>
The result is an array of conversions.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;ISo-8859-1&quot;, &quot;EUC-JP&quot;, crlf_newline: true)
  p ec.convpath
  #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
  #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
  #    &quot;crlf_newline&quot;]
</pre>
<p>
Each element of the array is a pair of encodings or a string. A pair means
an encoding conversion. A string means a decorator.
</p>
<p>
In the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means a
converter from ISO-8859-1 to UTF-8. &#8220;crlf_newline&#8220; means
newline converter from LF to CRLF.
</p>

        </div>
      </div>


      <div id="method-M000567" class="method-detail">
        <a name="M000567"></a>

        <div class="method-heading">

          <a href="Converter.src/M000567.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000567.html');return false;">

          <span class="method-name">ec.destination_encoding &rarr; encoding<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns the destination encoding as an <a
href="../Encoding.html">Encoding</a> object.
</p>

        </div>
      </div>


      <div id="method-M000570" class="method-detail">
        <a name="M000570"></a>

        <div class="method-heading">

          <a href="Converter.src/M000570.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000570.html');return false;">

          <span class="method-name">ec.finish &rarr; string<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Finishes the converter. It returns the last part of the converted string.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
  p ec.convert(&quot;\u3042&quot;)     #=&gt; &quot;\e$B$\&quot;&quot;
  p ec.finish                #=&gt; &quot;\e(B&quot;
</pre>

        </div>
      </div>


      <div id="method-M000572" class="method-detail">
        <a name="M000572"></a>

        <div class="method-heading">

          <a href="Converter.src/M000572.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000572.html');return false;">

          <span class="method-name">ec.insert_output(string) &rarr; nil<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Inserts string into the encoding converter. The string will be converted to
the destination encoding and output on later conversions.
</p>
<p>
If the destination encoding is stateful, string is converted according to
the state and the state is updated.
</p>
<p>
This method should be used only when a conversion error occurs.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 src = &quot;HIRAGANA LETTER A is \u{3042}.&quot;
 dst = &quot;&quot;
 p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &quot;, &quot;.&quot;]
 ec.insert_output(&quot;&lt;err&gt;&quot;)
 p ec.primitive_convert(src, dst)    #=&gt; :finished
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &lt;err&gt;.&quot;, &quot;&quot;]

 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
 src = &quot;\u{306F 3041 3068 2661 3002}&quot; # U+2661 is not representable in iso-2022-jp
 dst = &quot;&quot;
 p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;\xE3\x80\x82&quot;]
 ec.insert_output &quot;?&quot;                # state change required to output &quot;?&quot;.
 p ec.primitive_convert(src, dst)    #=&gt; :finished
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H\e(B?\e$B!#\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;&quot;]
</pre>

        </div>
      </div>


      <div id="method-M000564" class="method-detail">
        <a name="M000564"></a>

        <div class="method-heading">

          <a href="Converter.src/M000564.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000564.html');return false;">

          <span class="method-name">ec.inspect         &rarr; string<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns a printable version of <em>ec</em>
</p>
<pre>
  ec = Encoding::Converter.new(&quot;iso-8859-1&quot;, &quot;utf-8&quot;)
  puts ec.inspect    #=&gt; #&lt;Encoding::Converter: ISO-8859-1 to UTF-8&gt;
</pre>

        </div>
      </div>


      <div id="method-M000574" class="method-detail">
        <a name="M000574"></a>

        <div class="method-heading">

          <a href="Converter.src/M000574.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000574.html');return false;">

          <span class="method-name">ec.last_error &rarr; exception or nil<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns an exception object for the last conversion. Returns nil if the
last conversion did not produce an error.
</p>
<p>
&#8220;error&#8221; means that <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
and <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
for <a href="Converter.html#M000569">Encoding::Converter#convert</a> and
:invalid_byte_sequence, :incomplete_input and :undefined_conversion for <a
href="Converter.html#M000568">Encoding::Converter#primitive_convert</a>.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 p ec.primitive_convert(src=&quot;\xf1abcd&quot;, dst=&quot;&quot;)       #=&gt; :invalid_byte_sequence
 p ec.last_error      #=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xF1&quot; followed by &quot;a&quot; on UTF-8&gt;
 p ec.primitive_convert(src, dst, nil, 1)             #=&gt; :destination_buffer_full
 p ec.last_error      #=&gt; nil
</pre>

        </div>
      </div>


      <div id="method-M000568" class="method-detail">
        <a name="M000568"></a>

        <div class="method-heading">

          <a href="Converter.src/M000568.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000568.html');return false;">

          <span class="method-name">ec.primitive_convert(source_buffer, destination_buffer) &rarr; symbol<br />
ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset) &rarr; symbol<br />
ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) &rarr; symbol<br />
ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) &rarr; symbol<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
possible opt elements:
</p>
<pre>
  hash form:
    :partial_input =&gt; true           # source buffer may be part of larger source
    :after_output =&gt; true            # stop conversion after output before input
  integer form:
    Encoding::Converter::PARTIAL_INPUT
    Encoding::Converter::AFTER_OUTPUT
</pre>
<p>
possible results:
</p>
<pre>
   :invalid_byte_sequence
   :incomplete_input
   :undefined_conversion
   :after_output
   :destination_buffer_full
   :source_buffer_empty
   :finished
</pre>
<p>
<a href="Converter.html#M000568">primitive_convert</a> converts
source_buffer into destination_buffer.
</p>
<p>
source_buffer should be a string or nil. nil means a empty string.
</p>
<p>
destination_buffer should be a string.
</p>
<p>
destination_byteoffset should be an integer or nil. nil means the end of
destination_buffer. If it is omitted, nil is assumed.
</p>
<p>
destination_bytesize should be an integer or nil. nil means unlimited. If
it is omitted, nil is assumed.
</p>
<p>
opt should be nil, a hash or an integer. nil means no flags. If it is
omitted, nil is assumed.
</p>
<p>
<a href="Converter.html#M000568">primitive_convert</a> converts the content
of source_buffer from beginning and store the result into
destination_buffer.
</p>
<p>
destination_byteoffset and destination_bytesize specify the region which
the converted result is stored. destination_byteoffset specifies the start
position in destination_buffer in bytes. If destination_byteoffset is nil,
destination_buffer.bytesize is used for appending the result.
destination_bytesize specifies maximum number of bytes. If
destination_bytesize is nil, destination size is unlimited. After
conversion, destination_buffer is resized to destination_byteoffset +
actually produced number of bytes. Also destination_buffer&#8217;s encoding
is set to destination_encoding.
</p>
<p>
<a href="Converter.html#M000568">primitive_convert</a> drops the converted
part of source_buffer. the dropped part is converted in destination_buffer
or buffered in <a href="Converter.html">Encoding::Converter</a> object.
</p>
<p>
<a href="Converter.html#M000568">primitive_convert</a> stops conversion
when one of following condition met.
</p>
<ul>
<li>invalid byte sequence found in source buffer (:invalid_byte_sequence)

</li>
<li>unexpected end of source buffer (:incomplete_input) this occur only when
:partial_input is not specified.

</li>
<li>character not representable in output encoding (:undefined_conversion)

</li>
<li>after some output is generated, before input is done (:after_output) this
occur only when :after_output is specified.

</li>
<li>destination buffer is full (:destination_buffer_full) this occur only when
destination_bytesize is non-nil.

</li>
<li>source buffer is empty (:source_buffer_empty) this occur only when
:partial_input is specified.

</li>
<li>conversion is finished (:finished)

</li>
</ul>
<p>
example:
</p>
<pre>
  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
  ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, 100)
  p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]

  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
  ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, 1)
  p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;i&quot;]
</pre>

        </div>
      </div>


      <div id="method-M000571" class="method-detail">
        <a name="M000571"></a>

        <div class="method-heading">

          <a href="Converter.src/M000571.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000571.html');return false;">

          <span class="method-name">ec.primitive_errinfo &rarr; array<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
<a href="Converter.html#M000571">primitive_errinfo</a> returns important
information regarding the last error as a 5-element array:
</p>
<pre>
  [result, enc1, enc2, error_bytes, readagain_bytes]
</pre>
<p>
result is the last result of primitive_convert.
</p>
<p>
Other elements are only meaningful when result is :invalid_byte_sequence,
:incomplete_input or :undefined_conversion.
</p>
<p>
enc1 and enc2 indicate a conversion step as a pair of strings. For example,
a converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP
-> UTF-8 -> ISO-8859-1. So [enc1, enc2] is either [&#8220;EUC-JP&#8221;,
&#8220;UTF-8&#8221;] or [&#8220;UTF-8&#8221;, &#8220;ISO-8859-1&#8221;].
</p>
<p>
error_bytes and readagain_bytes indicate the byte sequences which caused
the error. error_bytes is discarded portion. readagain_bytes is buffered
portion which is read again on next conversion.
</p>
<p>
Example:
</p>
<pre>
  # \xff is invalid as EUC-JP.
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;Shift_JIS&quot;)
  ec.primitive_convert(src=&quot;\xff&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]

  # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
  # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
  # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4\xa2&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]

  # partial character is invalid
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]

  # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
  # partial characters.
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10, Encoding::Converter::PARTIAL_INPUT)
  p ec.primitive_errinfo
  #=&gt; [:source_buffer_empty, nil, nil, nil, nil]

  # \xd8\x00\x00@ is invalid as UTF-16BE because
  # no low surrogate after high surrogate (\xd8\x00).
  # It is detected by 3rd byte (\00) which is part of next character.
  # So the high surrogate (\xd8\x00) is discarded and
  # the 3rd byte is read again later.
  # Since the byte is buffered in ec, it is dropped from src.
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)
  ec.primitive_convert(src=&quot;\xd8\x00\x00@&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]
  p src
  #=&gt; &quot;@&quot;

  # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
  # The problem is detected by 4th byte.
  ec = Encoding::Converter.new(&quot;UTF-16LE&quot;, &quot;UTF-8&quot;)
  ec.primitive_convert(src=&quot;\x00\xd8@\x00&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]
  p src
  #=&gt; &quot;&quot;
</pre>

        </div>
      </div>


      <div id="method-M000573" class="method-detail">
        <a name="M000573"></a>

        <div class="method-heading">

          <a href="Converter.src/M000573.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000573.html');return false;">

          <span class="method-name">putback</span><span class="method-args">(...)</span>

          </a>

        </div>

        <div class="method-description">

          <p>
call-seq
</p>
<pre>
  ec.putback                    =&gt; string
  ec.putback(max_numbytes)      =&gt; string
</pre>
<p>
Put back the bytes which will be converted.
</p>
<p>
The bytes are caused by invalid_byte_sequence error. When
invalid_byte_sequence error, some bytes are discarded and some bytes are
buffered to be converted later. The latter bytes can be put back. It can be
observed by <a
href="InvalidByteSequenceError.html#M000559">Encoding::InvalidByteSequenceError#readagain_bytes</a>
and <a
href="Converter.html#M000571">Encoding::Converter#primitive_errinfo</a>.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;utf-16le&quot;, &quot;iso-8859-1&quot;)
  src = &quot;\x00\xd8\x61\x00&quot;
  dst = &quot;&quot;
  p ec.primitive_convert(src, dst)   #=&gt; :invalid_byte_sequence
  p ec.primitive_errinfo     #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;a\x00&quot;]
  p ec.putback               #=&gt; &quot;a\x00&quot;
  p ec.putback               #=&gt; &quot;&quot;          # no more bytes to put back
</pre>

        </div>
      </div>


      <div id="method-M000575" class="method-detail">
        <a name="M000575"></a>

        <div class="method-heading">

          <a href="Converter.src/M000575.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000575.html');return false;">

          <span class="method-name">ec.replacement &rarr; string<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns the replacement string.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;us-ascii&quot;)
 p ec.replacement    #=&gt; &quot;?&quot;

 ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
 p ec.replacement    #=&gt; &quot;\uFFFD&quot;
</pre>

        </div>
      </div>


      <div id="method-M000576" class="method-detail">
        <a name="M000576"></a>

        <div class="method-heading">

          <a href="Converter.src/M000576.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000576.html');return false;">

          <span class="method-name">ec.replacement = string<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Sets the replacement string.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;us-ascii&quot;, :undef =&gt; :replace)
 ec.replacement = &quot;&lt;undef&gt;&quot;
 p ec.convert(&quot;a \u3042 b&quot;)      #=&gt; &quot;a &lt;undef&gt; b&quot;
</pre>

        </div>
      </div>


      <div id="method-M000566" class="method-detail">
        <a name="M000566"></a>

        <div class="method-heading">

          <a href="Converter.src/M000566.html" target="Code" class="method-signature"
            onclick="popupCode('Converter.src/M000566.html');return false;">

          <span class="method-name">ec.source_encoding &rarr; encoding<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Returns the source encoding as an <a href="../Encoding.html">Encoding</a>
object.
</p>

        </div>
      </div>



    </div>




  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
