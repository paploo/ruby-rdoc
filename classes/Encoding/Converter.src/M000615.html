<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>primitive_convert (Encoding::Converter)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   ec.primitive_convert(source_buffer, destination_buffer) -&gt; symbol
 *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset) -&gt; symbol
 *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) -&gt; symbol
 *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) -&gt; symbol
 *
 * possible opt elements:
 *   hash form:
 *     :partial_input =&gt; true           # source buffer may be part of larger source
 *     :after_output =&gt; true            # stop conversion after output before input
 *   integer form:
 *     Encoding::Converter::PARTIAL_INPUT
 *     Encoding::Converter::AFTER_OUTPUT
 *
 * possible results:
 *    :invalid_byte_sequence
 *    :incomplete_input
 *    :undefined_conversion
 *    :after_output
 *    :destination_buffer_full
 *    :source_buffer_empty
 *    :finished
 *
 * primitive_convert converts source_buffer into destination_buffer.
 *
 * source_buffer should be a string or nil.
 * nil means a empty string.
 *
 * destination_buffer should be a string.
 *
 * destination_byteoffset should be an integer or nil.
 * nil means the end of destination_buffer.
 * If it is omitted, nil is assumed.
 *
 * destination_bytesize should be an integer or nil.
 * nil means unlimited.
 * If it is omitted, nil is assumed.
 *
 * opt should be nil, a hash or an integer.
 * nil means no flags.
 * If it is omitted, nil is assumed.
 *
 * primitive_convert converts the content of source_buffer from beginning
 * and store the result into destination_buffer.
 *
 * destination_byteoffset and destination_bytesize specify the region which
 * the converted result is stored.
 * destination_byteoffset specifies the start position in destination_buffer in bytes.
 * If destination_byteoffset is nil,
 * destination_buffer.bytesize is used for appending the result.
 * destination_bytesize specifies maximum number of bytes.
 * If destination_bytesize is nil,
 * destination size is unlimited.
 * After conversion, destination_buffer is resized to
 * destination_byteoffset + actually produced number of bytes.
 * Also destination_buffer's encoding is set to destination_encoding.
 *
 * primitive_convert drops the converted part of source_buffer.
 * the dropped part is converted in destination_buffer or
 * buffered in Encoding::Converter object.
 *
 * primitive_convert stops conversion when one of following condition met.
 * - invalid byte sequence found in source buffer (:invalid_byte_sequence)
 * - unexpected end of source buffer (:incomplete_input)
 *   this occur only when :partial_input is not specified.
 * - character not representable in output encoding (:undefined_conversion)
 * - after some output is generated, before input is done (:after_output)
 *   this occur only when :after_output is specified.
 * - destination buffer is full (:destination_buffer_full)
 *   this occur only when destination_bytesize is non-nil.
 * - source buffer is empty (:source_buffer_empty)
 *   this occur only when :partial_input is specified.
 * - conversion is finished (:finished)
 *
 * example:
 *   ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
 *   ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 100)
 *   p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]
 *
 *   ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
 *   ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]
 *   ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]
 *   ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]
 *   ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;i&quot;]
 *
 */
static VALUE
econv_primitive_convert(int argc, VALUE *argv, VALUE self)
{
    VALUE input, output, output_byteoffset_v, output_bytesize_v, opt, flags_v;
    rb_econv_t *ec = check_econv(self);
    rb_econv_result_t res;
    const unsigned char *ip, *is;
    unsigned char *op, *os;
    long output_byteoffset, output_bytesize;
    unsigned long output_byteend;
    int flags;

    rb_scan_args(argc, argv, &quot;23&quot;, &amp;input, &amp;output, &amp;output_byteoffset_v, &amp;output_bytesize_v, &amp;opt);

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = 0; /* dummy */
    else
        output_byteoffset = NUM2LONG(output_byteoffset_v);

    if (NIL_P(output_bytesize_v))
        output_bytesize = 0; /* dummy */
    else
        output_bytesize = NUM2LONG(output_bytesize_v);

    if (NIL_P(opt)) {
        flags = 0;
    }
    else if (!NIL_P(flags_v = rb_check_to_integer(opt, &quot;to_int&quot;))) {
        flags = NUM2INT(flags_v);
    }
    else {
        VALUE v;
        opt = rb_convert_type(opt, T_HASH, &quot;Hash&quot;, &quot;to_hash&quot;);
        flags = 0;
        v = rb_hash_aref(opt, sym_partial_input);
        if (RTEST(v))
            flags |= ECONV_PARTIAL_INPUT;
        v = rb_hash_aref(opt, sym_after_output);
        if (RTEST(v))
            flags |= ECONV_AFTER_OUTPUT;
    }

    StringValue(output);
    if (!NIL_P(input))
        StringValue(input);
    rb_str_modify(output);

    if (NIL_P(output_bytesize_v)) {
        output_bytesize = RSTRING_EMBED_LEN_MAX;
        if (!NIL_P(input) &amp;&amp; output_bytesize &lt; RSTRING_LEN(input))
            output_bytesize = RSTRING_LEN(input);
    }

  retry:

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = RSTRING_LEN(output);

    if (output_byteoffset &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_byteoffset&quot;);

    if (RSTRING_LEN(output) &lt; output_byteoffset)
        rb_raise(rb_eArgError, &quot;output_byteoffset too big&quot;);

    if (output_bytesize &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_bytesize&quot;);

    output_byteend = (unsigned long)output_byteoffset +
                     (unsigned long)output_bytesize;

    if (output_byteend &lt; (unsigned long)output_byteoffset ||
        LONG_MAX &lt; output_byteend)
        rb_raise(rb_eArgError, &quot;output_byteoffset+output_bytesize too big&quot;);

    if (rb_str_capacity(output) &lt; output_byteend)
        rb_str_resize(output, output_byteend);

    if (NIL_P(input)) {
        ip = is = NULL;
    }
    else {
        ip = (const unsigned char *)RSTRING_PTR(input);
        is = ip + RSTRING_LEN(input);
    }

    op = (unsigned char *)RSTRING_PTR(output) + output_byteoffset;
    os = op + output_bytesize;

    res = rb_econv_convert(ec, &amp;ip, is, &amp;op, os, flags);
    rb_str_set_len(output, op-(unsigned char *)RSTRING_PTR(output));
    if (!NIL_P(input))
        rb_str_drop_bytes(input, ip - (unsigned char *)RSTRING_PTR(input));

    if (NIL_P(output_bytesize_v) &amp;&amp; res == econv_destination_buffer_full) {
        if (LONG_MAX / 2 &lt; output_bytesize)
            rb_raise(rb_eArgError, &quot;too long conversion result&quot;);
        output_bytesize *= 2;
        output_byteoffset_v = Qnil;
        goto retry;
    }

    if (ec-&gt;destination_encoding) {
        rb_enc_associate(output, ec-&gt;destination_encoding);
    }

    return econv_result_to_symbol(res);
}</pre>
</body>
</html>
