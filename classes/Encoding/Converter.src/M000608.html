<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>asciicompat_encoding (Encoding::Converter)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   Encoding::Converter.asciicompat_encoding(string) =&gt; encoding or nil
 *   Encoding::Converter.asciicompat_encoding(encoding) =&gt; encoding or nil
 *
 * Returns the corresponding ASCII compatible encoding.
 *
 * Returns nil if the argument is an ASCII compatible encoding.
 *
 * &quot;corresponding ASCII compatible encoding&quot; is a ASCII compatible encoding which
 * can represents exactly the same characters as the given ASCII incompatible encoding.
 * So, no conversion undefined error occurs when converting between the two encodings.
 *
 *   Encoding::Converter.asciicompat_encoding(&quot;ISO-2022-JP&quot;) #=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;
 *   Encoding::Converter.asciicompat_encoding(&quot;UTF-16BE&quot;) #=&gt; #&lt;Encoding:UTF-8&gt;
 *   Encoding::Converter.asciicompat_encoding(&quot;UTF-8&quot;) #=&gt; nil
 *
 */
static VALUE
econv_s_asciicompat_encoding(VALUE klass, VALUE arg)
{
    const char *arg_name, *result_name;
    rb_encoding *arg_enc, *result_enc;

    enc_arg(&amp;arg, &amp;arg_name, &amp;arg_enc);

    result_name = rb_econv_asciicompat_encoding(arg_name);

    if (result_name == NULL)
        return Qnil;

    result_enc = make_encoding(result_name);

    return rb_enc_from_encoding(result_enc);
}</pre>
</body>
</html>
