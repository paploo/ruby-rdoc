<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>convert (Encoding::Converter)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   ec.convert(source_string) -&gt; destination_string
 *
 * Convert source_string and return destination_string.
 *
 * source_string is assumed as a part of source.
 * i.e.  :partial_input=&gt;true is specified internally.
 * finish method should be used last.
 *
 *   ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;euc-jp&quot;)
 *   puts ec.convert(&quot;\u3042&quot;).dump     #=&gt; &quot;\xA4\xA2&quot;
 *   puts ec.finish.dump                #=&gt; &quot;&quot;
 *
 *   ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
 *   puts ec.convert(&quot;\xA4&quot;).dump       #=&gt; &quot;&quot;
 *   puts ec.convert(&quot;\xA2&quot;).dump       #=&gt; &quot;\xE3\x81\x82&quot;
 *   puts ec.finish.dump                #=&gt; &quot;&quot;
 *
 *   ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
 *   puts ec.convert(&quot;\xE3&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *   puts ec.convert(&quot;\x81&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *   puts ec.convert(&quot;\x82&quot;).dump       #=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *   puts ec.finish.dump                #=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *
 * If a conversion error occur,
 * Encoding::UndefinedConversionError or
 * Encoding::InvalidByteSequenceError is raised.
 * Encoding::Converter#convert doesn't supply methods to recover or restart
 * from these exceptions.
 * When you want to handle these conversion errors,
 * use Encoding::Converter#primitive_convert.
 *
 */
static VALUE
econv_convert(VALUE self, VALUE source_string)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    StringValue(source_string);

    dst = rb_str_new(NULL, 0);

    av[0] = rb_str_dup(source_string);
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(ECONV_PARTIAL_INPUT);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret == sym_finished) {
        rb_raise(rb_eArgError, &quot;converter already finished&quot;);
    }

    if (ret != sym_source_buffer_empty) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</pre>
</body>
</html>
