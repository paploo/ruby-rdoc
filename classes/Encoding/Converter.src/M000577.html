<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>primitive_errinfo (Encoding::Converter)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   ec.primitive_errinfo -&gt; array
 *
 * primitive_errinfo returns important information regarding the last error
 * as a 5-element array:
 *
 *   [result, enc1, enc2, error_bytes, readagain_bytes]
 *
 * result is the last result of primitive_convert.
 *
 * Other elements are only meaningful when result is
 * :invalid_byte_sequence, :incomplete_input or :undefined_conversion.
 *
 * enc1 and enc2 indicate a conversion step as a pair of strings.
 * For example, a converter from EUC-JP to ISO-8859-1 converts
 * a string as follows: EUC-JP -&gt; UTF-8 -&gt; ISO-8859-1.
 * So [enc1, enc2] is either [&quot;EUC-JP&quot;, &quot;UTF-8&quot;] or [&quot;UTF-8&quot;, &quot;ISO-8859-1&quot;].
 *
 * error_bytes and readagain_bytes indicate the byte sequences which caused the error.
 * error_bytes is discarded portion.
 * readagain_bytes is buffered portion which is read again on next conversion.
 *
 * Example:
 *
 *   # \xff is invalid as EUC-JP.
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;Shift_JIS&quot;)
 *   ec.primitive_convert(src=&quot;\xff&quot;, dst=&quot;&quot;, nil, 10)                       
 *   p ec.primitive_errinfo
 *   #=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]
 *
 *   # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
 *   # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
 *   # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
 *   ec.primitive_convert(src=&quot;\xa4\xa2&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]
 *
 *   # partial character is invalid
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
 *   ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]
 *
 *   # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
 *   # partial characters.
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
 *   ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10, Encoding::Converter::PARTIAL_INPUT)                 
 *   p ec.primitive_errinfo
 *   #=&gt; [:source_buffer_empty, nil, nil, nil, nil]
 *
 *   # \xd8\x00\x00@ is invalid as UTF-16BE because
 *   # no low surrogate after high surrogate (\xd8\x00).
 *   # It is detected by 3rd byte (\00) which is part of next character.
 *   # So the high surrogate (\xd8\x00) is discarded and
 *   # the 3rd byte is read again later.
 *   # Since the byte is buffered in ec, it is dropped from src.
 *   ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)
 *   ec.primitive_convert(src=&quot;\xd8\x00\x00@&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]
 *   p src
 *   #=&gt; &quot;@&quot;
 *
 *   # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
 *   # The problem is detected by 4th byte.
 *   ec = Encoding::Converter.new(&quot;UTF-16LE&quot;, &quot;UTF-8&quot;)
 *   ec.primitive_convert(src=&quot;\x00\xd8@\x00&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]
 *   p src
 *   #=&gt; &quot;&quot;
 *
 */
static VALUE
econv_primitive_errinfo(VALUE self)
{
    rb_econv_t *ec = check_econv(self);

    VALUE ary;

    ary = rb_ary_new2(5);

    rb_ary_store(ary, 0, econv_result_to_symbol(ec-&gt;last_error.result));
    rb_ary_store(ary, 4, Qnil);

    if (ec-&gt;last_error.source_encoding)
        rb_ary_store(ary, 1, rb_str_new2(ec-&gt;last_error.source_encoding));

    if (ec-&gt;last_error.destination_encoding)
        rb_ary_store(ary, 2, rb_str_new2(ec-&gt;last_error.destination_encoding));

    if (ec-&gt;last_error.error_bytes_start) {
        rb_ary_store(ary, 3, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start, ec-&gt;last_error.error_bytes_len));
        rb_ary_store(ary, 4, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start + ec-&gt;last_error.error_bytes_len, ec-&gt;last_error.readagain_len));
    }

    return ary;
}</pre>
</body>
</html>
