<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>sample (Array)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     array.sample        -&gt; obj
 *     array.sample(n)     -&gt; an_array
 *  
 *  Choose a random element, or the random +n+ elements, from the array.
 *  If the array is empty, the first form returns &lt;code&gt;nil&lt;/code&gt;, and the
 *  second form returns an empty array.
 *  
 */


static VALUE
rb_ary_sample(int argc, VALUE *argv, VALUE ary)
{
    VALUE nv, result, *ptr;
    long n, len, i, j, k, idx[10];

    len = RARRAY_LEN(ary); 
    if (argc == 0) {
        if (len == 0) return Qnil;
        i = len == 1 ? 0 : rb_genrand_real()*len;
        return RARRAY_PTR(ary)[i];
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;nv);
    n = NUM2LONG(nv);
    ptr = RARRAY_PTR(ary); 
    len = RARRAY_LEN(ary); 
    if (n &gt; len) n = len;
    switch (n) {
      case 0: return rb_ary_new2(0);
      case 1:
        return rb_ary_new4(1, &amp;ptr[(long)(rb_genrand_real()*len)]);
      case 2:
        i = rb_genrand_real()*len;
        j = rb_genrand_real()*(len-1);
        if (j &gt;= i) j++;
        return rb_ary_new3(2, ptr[i], ptr[j]);
      case 3:
        i = rb_genrand_real()*len;
        j = rb_genrand_real()*(len-1);
        k = rb_genrand_real()*(len-2);
        {
            long l = j, g = i;
            if (j &gt;= i) l = i, g = ++j;
            if (k &gt;= l &amp;&amp; (++k &gt;= g)) ++k;
        }
        return rb_ary_new3(3, ptr[i], ptr[j], ptr[k]);
    }
    if (n &lt; sizeof(idx)/sizeof(idx[0])) {
        long sorted[sizeof(idx)/sizeof(idx[0])];
        sorted[0] = idx[0] = rb_genrand_real()*len;
        for (i=1; i&lt;n; i++) {
            k = rb_genrand_real()*--len;
            for (j = 0; j &lt; i; ++j) {
                if (k &lt; sorted[j]) break;
                ++k;
            }
            memmove(&amp;sorted[j+1], &amp;sorted[j], sizeof(sorted[0])*(i-j));
            sorted[j] = idx[i] = k;
        }
        result = rb_ary_new2(n);
        for (i=0; i&lt;n; i++) {
            RARRAY_PTR(result)[i] = RARRAY_PTR(ary)[idx[i]];
        }
    }
    else {
        result = rb_ary_new4(len, ptr);
        RB_GC_GUARD(ary);
        for (i=0; i&lt;n; i++) {
            j = (long)(rb_genrand_real()*(len-i)) + i;
            nv = RARRAY_PTR(result)[j];
            RARRAY_PTR(result)[j] = RARRAY_PTR(result)[i];
            RARRAY_PTR(result)[i] = nv;
        }
    }
    ARY_SET_LEN(result, n);

    return result;
}</pre>
</body>
</html>
