<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>combination (Array)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     ary.combination(n) { |c| block }    -&gt; ary
 *     ary.combination(n)                  -&gt; enumerator
 *  
 * When invoked with a block, yields all combinations of length &lt;i&gt;n&lt;/i&gt; 
 * of elements from &lt;i&gt;ary&lt;/i&gt; and then returns &lt;i&gt;ary&lt;/i&gt; itself.
 * The implementation makes no guarantees about the order in which 
 * the combinations are yielded.
 *
 * When invoked without a block, returns an enumerator object instead.
 *     
 * Examples:
 *
 *     a = [1, 2, 3, 4]
 *     a.combination(1).to_a  #=&gt; [[1],[2],[3],[4]]
 *     a.combination(2).to_a  #=&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
 *     a.combination(3).to_a  #=&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
 *     a.combination(4).to_a  #=&gt; [[1,2,3,4]]
 *     a.combination(0).to_a  #=&gt; [[]] # one combination of length 0
 *     a.combination(5).to_a  #=&gt; []   # no combinations of length 5
 *     
 */

static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);
    RETURN_ENUMERATOR(ary, 1, &amp;num);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; len; i++) {
            rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
        }
    }
    else {
        volatile VALUE t0 = tmpbuf(n+1, sizeof(long));
        long *stack = (long*)RSTRING_PTR(t0);
        long nlen = combi_len(len, n);
        volatile VALUE cc = tmpary(n);
        VALUE *chosen = RARRAY_PTR(cc);
        long lev = 0;

        MEMZERO(stack, long, n);
        stack[0] = -1;
        for (i = 0; i &lt; nlen; i++) {
            chosen[lev] = RARRAY_PTR(ary)[stack[lev+1]];
            for (lev++; lev &lt; n; lev++) {
                chosen[lev] = RARRAY_PTR(ary)[stack[lev+1] = stack[lev]+1];
            }
            rb_yield(rb_ary_new4(n, chosen));
            if (RBASIC(t0)-&gt;klass) {
                rb_raise(rb_eRuntimeError, &quot;combination reentered&quot;);
            }
            do {
                stack[lev--]++;
            } while (lev &amp;&amp; (stack[lev+1]+n == len+lev+1));
        }
    }
    return ary;
}</pre>
</body>
</html>
