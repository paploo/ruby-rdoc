<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>permutation (Array)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     ary.permutation { |p| block }          -&gt; array
 *     ary.permutation                        -&gt; enumerator
 *     ary.permutation(n) { |p| block }       -&gt; array
 *     ary.permutation(n)                     -&gt; enumerator
 *  
 * When invoked with a block, yield all permutations of length &lt;i&gt;n&lt;/i&gt;
 * of the elements of &lt;i&gt;ary&lt;/i&gt;, then return the array itself.
 * If &lt;i&gt;n&lt;/i&gt; is not specified, yield all permutations of all elements.
 * The implementation makes no guarantees about the order in which 
 * the permutations are yielded.
 *
 * When invoked without a block, return an enumerator object instead.
 * 
 * Examples:
 *
 *     a = [1, 2, 3]
 *     a.permutation.to_a     #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 *     a.permutation(1).to_a  #=&gt; [[1],[2],[3]]
 *     a.permutation(2).to_a  #=&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
 *     a.permutation(3).to_a  #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 *     a.permutation(0).to_a  #=&gt; [[]] # one permutation of length 0
 *     a.permutation(4).to_a  #=&gt; []   # no permutations of length 4
 */

static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    VALUE num;
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_ENUMERATOR(ary, argc, argv);   /* Return enumerator if no block */
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);
    r = NIL_P(num) ? n : NUM2LONG(num);   /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) { 
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0 = tmpbuf(n,sizeof(long));
        long *p = (long*)RSTRING_PTR(t0);
        volatile VALUE t1 = tmpbuf(n,sizeof(int));
        int *used = (int*)RSTRING_PTR(t1);
        VALUE ary0 = ary_make_substitution(ary); /* private defensive copy of ary */
        RBASIC(ary0)-&gt;klass = 0;

        for (i = 0; i &lt; n; i++) used[i] = 0; /* initialize array */

        permute0(n, r, p, 0, used, ary0); /* compute and yield permutations */
        RB_GC_GUARD(t0);
        RB_GC_GUARD(t1);
        RBASIC(ary0)-&gt;klass = rb_cArray;
    }
    return ary;
}</pre>
</body>
</html>
