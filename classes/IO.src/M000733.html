<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>pipe (IO)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     IO.pipe                            -&gt; [read_io, write_io]
 *     IO.pipe(ext_enc)                   -&gt; [read_io, write_io]
 *     IO.pipe(&quot;ext_enc:int_enc&quot; [, opt]) -&gt; [read_io, write_io]
 *     IO.pipe(ext_enc, int_enc [, opt])  -&gt; [read_io, write_io]
 *
 *  Creates a pair of pipe endpoints (connected to each other) and
 *  returns them as a two-element array of &lt;code&gt;IO&lt;/code&gt; objects:
 *  &lt;code&gt;[&lt;/code&gt; &lt;i&gt;read_io&lt;/i&gt;, &lt;i&gt;write_io&lt;/i&gt; &lt;code&gt;]&lt;/code&gt;. Not
 *  available on all platforms.
 *
 *  If an encoding (encoding name or encoding object) is specified as an optional argument,
 *  read string from pipe is tagged with the encoding specified.
 *  If the argument is a colon separated two encoding names &quot;A:B&quot;,
 *  the read string is converted from encoding A (external encoding)
 *  to encoding B (internal encoding), then tagged with B.
 *  If two optional arguments are specified, those must be
 *  encoding objects or encoding names,
 *  and the first one is the external encoding,
 *  and the second one is the internal encoding.
 *  If the external encoding and the internal encoding is specified,
 *  optional hash argument specify the conversion option.
 *
 *  In the example below, the two processes close the ends of the pipe
 *  that they are not using. This is not just a cosmetic nicety. The
 *  read end of a pipe will not generate an end of file condition if
 *  there are any writers with the pipe still open. In the case of the
 *  parent process, the &lt;code&gt;rd.read&lt;/code&gt; will never return if it
 *  does not first issue a &lt;code&gt;wr.close&lt;/code&gt;.
 *
 *     rd, wr = IO.pipe
 *
 *     if fork
 *       wr.close
 *       puts &quot;Parent got: &lt;#{rd.read}&gt;&quot;
 *       rd.close
 *       Process.wait
 *     else
 *       rd.close
 *       puts &quot;Sending message to parent&quot;
 *       wr.write &quot;Hi Dad&quot;
 *       wr.close
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Sending message to parent
 *     Parent got: &lt;Hi Dad&gt;
 */

static VALUE
rb_io_s_pipe(int argc, VALUE *argv, VALUE klass)
{
    int pipes[2], state;
    VALUE r, w, args[3], v1, v2;
    VALUE opt;
    rb_io_t *fptr, *fptr2;
    int fmode = 0;

    opt = pop_last_hash(&amp;argc, argv);
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;v1, &amp;v2);
    if (rb_pipe(pipes) == -1)
        rb_sys_fail(0);

    args[0] = klass;
    args[1] = INT2NUM(pipes[0]);
    args[2] = INT2FIX(O_RDONLY);
    r = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
        close(pipes[0]);
        close(pipes[1]);
        rb_jump_tag(state);
    }
    GetOpenFile(r, fptr);
    io_encoding_set(fptr, v1, v2, opt);
    args[1] = INT2NUM(pipes[1]);
    args[2] = INT2FIX(O_WRONLY);
    w = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
        close(pipes[1]);
        if (!NIL_P(r)) rb_io_close(r);
        rb_jump_tag(state);
    }
    GetOpenFile(w, fptr2);
    rb_io_synchronized(fptr2);

    extract_binmode(opt, &amp;fmode);
    fptr-&gt;mode |= fmode;
    fptr2-&gt;mode |= fmode;

    return rb_assoc_new(r, w);
}</pre>
</body>
</html>
