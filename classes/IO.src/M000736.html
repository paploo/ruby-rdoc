<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>new (IO)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     IO.new(fd [, mode] [, opt])   =&gt; io
 *
 *  Returns a new &lt;code&gt;IO&lt;/code&gt; object (a stream) for the given
 *  &lt;code&gt;IO&lt;/code&gt; object or integer file descriptor and mode
 *  string. See also &lt;code&gt;IO#fileno&lt;/code&gt; and
 *  &lt;code&gt;IO.for_fd&lt;/code&gt;.
 *  
 *  === Parameters
 *  fd:: numeric file descriptor
 *  mode:: file mode. a string or an integer
 *  opt:: hash for specifiying mode by name.
 *
 *  ==== Mode
 *  When &lt;code&gt;mode&lt;/code&gt; is an integer it must be combination of
 *  the modes defined in &lt;code&gt;File::Constants&lt;/code&gt;.
 *
 *  When &lt;code&gt;mode&lt;/code&gt; is a string it must be in one of the 
 *  following forms:
 *  - &quot;fmode&quot;,
 *  - &quot;fmode:extern&quot;,
 *  - &quot;fmode:extern:intern&quot;.
 *  &lt;code&gt;extern&lt;/code&gt; is the external encoding name for the IO. 
 *  &lt;code&gt;intern&lt;/code&gt; is the internal encoding.
 *  &lt;code&gt;fmode&lt;/code&gt; must be combination of the directives. See
 *  the description of class +IO+ for a description of the directives.
 *
 *  ==== Options
 *  &lt;code&gt;opt&lt;/code&gt; can have the following keys
 *  :mode ::
 *    same as &lt;code&gt;mode&lt;/code&gt; parameter
 *  :external_encoding :: 
 *    external encoding for the IO. &quot;-&quot; is a 
 *    synonym for the default external encoding.
 *  :internal_encoding ::
 *    internal encoding for the IO. 
 *    &quot;-&quot; is a synonym for the default internal encoding.
 *    If the value is nil no conversion occurs. 
 *  :encoding :: 
 *    specifies external and internal encodings as &quot;extern:intern&quot;.
 *  :textmode ::
 *    If the value is truth value, same as &quot;b&quot; in argument &lt;code&gt;mode&lt;/code&gt;.
 *  :binmode ::
 *    If the value is truth value, same as &quot;t&quot; in argument &lt;code&gt;mode&lt;/code&gt;.
 *  
 *  Also &lt;code&gt;opt&lt;/code&gt; can have same keys in &lt;code&gt;String#encode&lt;/code&gt; for
 *  controlling conversion between the external encoding and the internal encoding.
 *
 *  === Example1
 *
 *     puts IO.new($stdout).fileno # =&gt; 1
 *
 *     a = IO.new(2,&quot;w&quot;)      # '2' is standard error
 *     $stderr.puts &quot;Hello&quot;
 *     a.puts &quot;World&quot;
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Hello
 *     World
 *
 *  === Example2
 *     io = IO.new(2, mode: 'w:UTF-16LE', cr_newline: true)
 *     io.puts &quot;Hello, World!&quot;
 *
 *     io = IO.new(2, mode: 'w', cr_newline: true, external_encoding: Encoding::UTF_16LE)
 *     io.puts &quot;Hello, World!&quot;
 *
 *  both of aboves print &quot;Hello, World!&quot; in UTF-16LE to standard error output with 
 *  converting EOL generated by &lt;code&gt;puts&lt;/code&gt; to CR.
 */

static VALUE
rb_io_initialize(int argc, VALUE *argv, VALUE io)
{
    VALUE fnum, vmode;
    rb_io_t *fp;
    int fd, fmode, oflags = O_RDONLY;
    convconfig_t convconfig;
    VALUE opt;
    struct stat st;

    rb_secure(4);

    opt = pop_last_hash(&amp;argc, argv);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;fnum, &amp;vmode);
    rb_io_extract_modeenc(&amp;vmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

    fd = NUM2INT(fnum);
    if (fstat(fd, &amp;st) == -1) rb_sys_fail(0);
    UPDATE_MAXFD(fd);
    if (NIL_P(vmode)) {
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
        oflags = fcntl(fd, F_GETFL);
        if (oflags == -1) rb_sys_fail(0);
        fmode = rb_io_oflags_fmode(oflags);
#endif
    }
    MakeOpenFile(io, fp);
    fp-&gt;fd = fd;
    fp-&gt;mode = fmode;
    fp-&gt;encs = convconfig;
    clear_codeconv(fp);
    io_check_tty(fp);
    if (fileno(stdin) == fd)
        fp-&gt;stdio_file = stdin;
    else if (fileno(stdout) == fd)
        fp-&gt;stdio_file = stdout;
    else if (fileno(stderr) == fd)
        fp-&gt;stdio_file = stderr;

    return io;
}</pre>
</body>
</html>
