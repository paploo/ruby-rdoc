<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>read_nonblock (IO)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     ios.read_nonblock(maxlen)              =&gt; string
 *     ios.read_nonblock(maxlen, outbuf)      =&gt; outbuf
 *
 *  Reads at most &lt;i&gt;maxlen&lt;/i&gt; bytes from &lt;em&gt;ios&lt;/em&gt; using
 *  the read(2) system call after O_NONBLOCK is set for
 *  the underlying file descriptor.
 *
 *  If the optional &lt;i&gt;outbuf&lt;/i&gt; argument is present,
 *  it must reference a String, which will receive the data.
 *
 *  read_nonblock just calls the read(2) system call.
 *  It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc.
 *  The caller should care such errors.
 *
 *  read_nonblock causes EOFError on EOF.
 *
 *  If the read buffer is not empty,
 *  read_nonblock reads from the buffer like readpartial.
 *  In this case, the read(2) system call is not called.
 *
 *  When read_nonblock raises EWOULDBLOCK,
 *  read_nonblock should not be called
 *  until io is readable for avoiding busy loop.
 *  This can be done as follows.
 *
 *    begin
 *      result = io.read_nonblock(maxlen)
 *    rescue Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::EINTR
 *      IO.select([io])
 *      retry
 *    end
 *
 *  Note that this is identical to readpartial
 *  except the non-blocking flag is set.
 */

static VALUE
io_read_nonblock(int argc, VALUE *argv, VALUE io)
{
    VALUE ret;

    ret = io_getpartial(argc, argv, io, 1);
    if (NIL_P(ret))
        rb_eof_error();
    else
        return ret;
}</pre>
</body>
</html>
