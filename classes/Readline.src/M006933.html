<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>readline (Readline)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   Readline.readline(prompt = &quot;&quot;, add_hist = false) -&gt; string or nil
 *
 * Shows the +prompt+ and reads the inputted line with line editing.
 * The inputted line is added to the history if +add_hist+ is true.
 *
 * Returns nil when the inputted line is empty and user inputs EOF
 * (Presses ^D on UNIX).
 *
 * Raises IOError exception if below conditions are satisfied.
 * 1. stdin is not tty.
 * 2. stdin was closed. (errno is EBADF after called isatty(2).)
 *
 * This method supports thread. Switchs the thread context when waits
 * inputting line.
 *
 * Supports line edit when inputs line. Provides VI and Emacs editing mode.
 * Default is Emacs editing mode.
 *
 * NOTE: Terminates ruby interpreter and does not return the terminal
 * status after user pressed '^C' when wait inputting line.
 * Give 3 examples that avoid it.
 *
 * * Catches the Interrupt exception by pressed ^C after returns
 *   terminal status:
 * 
 *     require &quot;readline&quot;
 *     
 *     stty_save = `stty -g`.chomp
 *     begin
 *       while buf = Readline.readline
 *           p buf
 *           end
 *         rescue Interrupt
 *           system(&quot;stty&quot;, stty_save)
 *           exit
 *         end
 *       end
 *     end
 * 
 * * Catches the INT signal by pressed ^C after returns terminal
 *   status:
 * 
 *     require &quot;readline&quot;
 *     
 *     stty_save = `stty -g`.chomp
 *     trap(&quot;INT&quot;) { system &quot;stty&quot;, stty_save; exit }
 *   
 *     while buf = Readline.readline
 *       p buf
 *     end
 *
 * * Ignores pressing ^C:
 * 
 *     require &quot;readline&quot;
 *     
 *     trap(&quot;INT&quot;, &quot;SIG_IGN&quot;)
 *     
 *     while buf = Readline.readline
 *       p buf
 *     end
 *
 * Can make as follows with Readline::HISTORY constant.
 * It does not record to the history if the inputted line is empty or
 * the same it as last one.
 *
 *   require &quot;readline&quot;
 *     
 *   while buf = Readline.readline(&quot;&gt; &quot;, true)
 *     # p Readline::HISTORY.to_a
 *     Readline::HISTORY.pop if /^\s*$/ =~ buf
 *  
 *     begin
 *       if Readline::HISTORY[Readline::HISTORY.length-2] == buf
 *         Readline::HISTORY.pop 
 *       end
 *     rescue IndexError
 *     end
 *  
 *     # p Readline::HISTORY.to_a
 *     print &quot;-&gt; &quot;, buf, &quot;\n&quot;
 *   end
 *
 * Raises SecurityError exception if $SAFE is 4.
 */
static VALUE
readline_readline(int argc, VALUE *argv, VALUE self)
{
    VALUE tmp, add_hist, result;
    char *prompt = NULL;
    char *buff;
    int status;

    rb_secure(4);
    if (rb_scan_args(argc, argv, &quot;02&quot;, &amp;tmp, &amp;add_hist) &gt; 0) {
        OutputStringValue(tmp);
        prompt = RSTRING_PTR(tmp);
    }

    if (!isatty(0) &amp;&amp; errno == EBADF) rb_raise(rb_eIOError, &quot;closed stdin&quot;);

    buff = (char*)rb_protect((VALUE(*)_((VALUE)))readline, (VALUE)prompt,
                              &amp;status);
    if (status) {
#if defined HAVE_RL_CLEANUP_AFTER_SIGNAL
        /* restore terminal mode and signal handler*/
        rl_cleanup_after_signal();
#elif defined HAVE_RL_DEPREP_TERM_FUNCTION
        /* restore terminal mode */
        if (rl_deprep_term_function != NULL) /* NULL in libedit. [ruby-dev:29116] */
            (*rl_deprep_term_function)();
        else
#else
        rl_deprep_terminal();
#endif
        rb_jump_tag(status);
    }

    if (RTEST(add_hist) &amp;&amp; buff) {
        add_history(buff);
    }
    if (buff) {
        result = rb_locale_str_new_cstr(buff);
    }
    else
        result = Qnil;
    if (buff) free(buff);
    return result;
}</pre>
</body>
</html>
