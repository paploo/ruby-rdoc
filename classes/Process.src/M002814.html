<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>waitall (Process)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     Process.waitall   =&gt; [ [pid1,status1], ...]
 *
 *  Waits for all children, returning an array of
 *  _pid_/_status_ pairs (where _status_ is a
 *  &lt;code&gt;Process::Status&lt;/code&gt; object).
 *
 *     fork { sleep 0.2; exit 2 }   #=&gt; 27432
 *     fork { sleep 0.1; exit 1 }   #=&gt; 27433
 *     fork {            exit 0 }   #=&gt; 27434
 *     p Process.waitall
 *
 *  &lt;em&gt;produces&lt;/em&gt;:
 *
 *     [[27434, #&lt;Process::Status: pid=27434,exited(0)&gt;],
 *      [27433, #&lt;Process::Status: pid=27433,exited(1)&gt;],
 *      [27432, #&lt;Process::Status: pid=27432,exited(2)&gt;]]
 */

static VALUE
proc_waitall(void)
{
    VALUE result;
    rb_pid_t pid;
    int status;

    rb_secure(2);
    result = rb_ary_new();
#ifdef NO_WAITPID
    if (pid_tbl) {
        st_foreach(pid_tbl, waitall_each, result);
    }
#else
    rb_last_status_clear();
#endif

    for (pid = -1;;) {
#ifdef NO_WAITPID
        pid = wait(&amp;status);
#else
        pid = rb_waitpid(-1, &amp;status, 0);
#endif
        if (pid == -1) {
            if (errno == ECHILD)
                break;
#ifdef NO_WAITPID
            if (errno == EINTR) {
                rb_thread_schedule();
                continue;
            }
#endif
            rb_sys_fail(0);
        }
#ifdef NO_WAITPID
        rb_last_status_set(status, pid);
#endif
        rb_ary_push(result, rb_assoc_new(PIDT2NUM(pid), rb_last_status_get()));
    }
    return result;
}</pre>
</body>
</html>
