<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>step (Numeric)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     num.step(limit, step ) {|i| block }     =&gt; num
 *
 *  Invokes &lt;em&gt;block&lt;/em&gt; with the sequence of numbers starting at
 *  &lt;i&gt;num&lt;/i&gt;, incremented by &lt;i&gt;step&lt;/i&gt; on each call. The loop
 *  finishes when the value to be passed to the block is greater than
 *  &lt;i&gt;limit&lt;/i&gt; (if &lt;i&gt;step&lt;/i&gt; is positive) or less than
 *  &lt;i&gt;limit&lt;/i&gt; (if &lt;i&gt;step&lt;/i&gt; is negative). If all the arguments are
 *  integers, the loop operates using an integer counter. If any of the
 *  arguments are floating point numbers, all are converted to floats,
 *  and the loop is executed &lt;i&gt;floor(n + n*epsilon)+ 1&lt;/i&gt; times,
 *  where &lt;i&gt;n = (limit - num)/step&lt;/i&gt;. Otherwise, the loop
 *  starts at &lt;i&gt;num&lt;/i&gt;, uses either the &lt;code&gt;&lt;&lt;/code&gt; or
 *  &lt;code&gt;&gt;&lt;/code&gt; operator to compare the counter against
 *  &lt;i&gt;limit&lt;/i&gt;, and increments itself using the &lt;code&gt;+&lt;/code&gt;
 *  operator.
 *
 *     1.step(10, 2) { |i| print i, &quot; &quot; }
 *     Math::E.step(Math::PI, 0.2) { |f| print f, &quot; &quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     1 3 5 7 9
 *     2.71828182845905 2.91828182845905 3.11828182845905
 */

static VALUE
num_step(int argc, VALUE *argv, VALUE from)
{
    VALUE to, step;

    RETURN_ENUMERATOR(from, argc, argv);
    if (argc == 1) {
        to = argv[0];
        step = INT2FIX(1);
    }
    else {
        if (argc == 2) {
            to = argv[0];
            step = argv[1];
        }
        else {
            rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
        }
        if (rb_equal(step, INT2FIX(0))) {
            rb_raise(rb_eArgError, &quot;step can't be 0&quot;);
        }
    }

    if (FIXNUM_P(from) &amp;&amp; FIXNUM_P(to) &amp;&amp; FIXNUM_P(step)) {
        long i, end, diff;

        i = FIX2LONG(from);
        end = FIX2LONG(to);
        diff = FIX2LONG(step);

        if (diff &gt; 0) {
            while (i &lt;= end) {
                rb_yield(LONG2FIX(i));
                i += diff;
            }
        }
        else {
            while (i &gt;= end) {
                rb_yield(LONG2FIX(i));
                i += diff;
            }
        }
    }
    else if (!ruby_float_step(from, to, step, Qfalse)) {
        VALUE i = from;
        ID cmp;

        if (RTEST(rb_funcall(step, '&gt;', 1, INT2FIX(0)))) {
            cmp = '&gt;';
        }
        else {
            cmp = '&lt;';
        }
        for (;;) {
            if (RTEST(rb_funcall(i, cmp, 1, to))) break;
            rb_yield(i);
            i = rb_funcall(i, '+', 1, step);
        }
    }
    return from;
}</pre>
</body>
</html>
