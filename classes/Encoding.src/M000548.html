<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>locale_charmap (Encoding)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   Encoding.locale_charmap =&gt; string
 *
 * Returns the locale charmap name.
 *
 *   Debian GNU/Linux
 *     LANG=C
 *       Encoding.locale_charmap  =&gt; &quot;ANSI_X3.4-1968&quot;
 *     LANG=ja_JP.EUC-JP
 *       Encoding.locale_charmap  =&gt; &quot;EUC-JP&quot;
 *
 *   SunOS 5
 *     LANG=C
 *       Encoding.locale_charmap  =&gt; &quot;646&quot;
 *     LANG=ja
 *       Encoding.locale_charmap  =&gt; &quot;eucJP&quot;
 *
 * The result is higly platform dependent.
 * So Encoding.find(Encoding.locale_charmap) may cause an error.
 * If you need some encoding object even for unknown locale,
 * Encoding.find(&quot;locale&quot;) can be used.
 *
 */
VALUE
rb_locale_charmap(VALUE klass)
{
#if defined NO_LOCALE_CHARMAP
    return rb_usascii_str_new2(&quot;ASCII-8BIT&quot;);
#elif defined _WIN32 || defined __CYGWIN__
    const char *nl_langinfo_codeset(void);
    const char *codeset = nl_langinfo_codeset();
    char cp[sizeof(int) * 3 + 4];
    if (!codeset) {
        snprintf(cp, sizeof(cp), &quot;CP%d&quot;, GetConsoleCP());
        codeset = cp;
    }
    return rb_usascii_str_new2(codeset);
#elif defined HAVE_LANGINFO_H
    char *codeset;
    codeset = nl_langinfo(CODESET);
    return rb_usascii_str_new2(codeset);
#else
    return Qnil;
#endif
}</pre>
</body>
</html>
