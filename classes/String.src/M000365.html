<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>encode (String)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     str.encode(encoding [, options] )   =&gt; str
 *     str.encode(dst_encoding, src_encoding [, options] )   =&gt; str
 *     str.encode([options])   =&gt; str
 *
 *  The first form returns a copy of &lt;i&gt;str&lt;/i&gt; transcoded
 *  to encoding +encoding+.
 *  The second form returns a copy of &lt;i&gt;str&lt;/i&gt; transcoded
 *  from src_encoding to dst_encoding.
 *  The last form returns a copy of &lt;i&gt;str&lt;/i&gt; transcoded to
 *  &lt;code&gt;Encoding.default_internal&lt;/code&gt;.
 *  By default, the first and second form raise
 *  Encoding::UndefinedConversionError for characters that are
 *  undefined in the destination encoding, and
 *  Encoding::InvalidByteSequenceError for invalid byte sequences
 *  in the source encoding. The last form by default does not raise
 *  exceptions but uses replacement strings.
 *  The &lt;code&gt;options&lt;/code&gt; Hash gives details for conversion.
 *
 *  === options
 *  The hash &lt;code&gt;options&lt;/code&gt; can have the following keys:
 *  :invalid ::
 *    If the value is &lt;code&gt;:replace&lt;/code&gt;, &lt;code&gt;#encode&lt;/code&gt; replaces
 *    invalid byte sequences in &lt;code&gt;str&lt;/code&gt; with the replacement character.
 *    The default is to raise the exception
 *  :undef ::
 *    If the value is &lt;code&gt;:replace&lt;/code&gt;, &lt;code&gt;#encode&lt;/code&gt; replaces
 *    characters which are undefined in the destination encoding with
 *    the replacement character.
 *  :replace ::
 *    Sets the replacement string to the value. The default replacement
 *    string is &quot;\uFFFD&quot; for Unicode encoding forms, and &quot;?&quot; otherwise.
 *  :xml ::
 *    The value must be &lt;code&gt;:text&lt;/code&gt; or &lt;code&gt;:attr&lt;/code&gt;.
 *    If the value is &lt;code&gt;:text&lt;/code&gt; &lt;code&gt;#encode&lt;/code&gt; replaces
 *    undefined characters with their (upper-case hexadecimal) numeric
 *    character references. '&amp;', '&lt;', and '&gt;' are converted to &quot;&amp;amp;&quot;,
 *    &quot;&amp;lt;&quot;, and &quot;&amp;gt;&quot;, respectively.
 *    If the value is &lt;code&gt;:attr&lt;/code&gt;, &lt;code&gt;#encode&lt;/code&gt; also quotes
 *    the replacement result (using '&quot;'), and replaces '&quot;' with &quot;&amp;quot;&quot;.
 *  :cr_newline ::
 *    Replaces LF (&quot;\n&quot;) with CR (&quot;\r&quot;) if value is true.
 *  :crlf_newline ::
 *    Replaces LF (&quot;\n&quot;) with CRLF (&quot;\r\n&quot;) if value is true.
 *  :universal_newline ::
 *    Replaces CRLF (&quot;\r\n&quot;) and CR (&quot;\r&quot;) with LF (&quot;\n&quot;) if value is true.
 */

static VALUE
str_encode(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr = str;
    int encidx = str_transcode(argc, argv, &amp;newstr);

    if (encidx &lt; 0) return rb_str_dup(str);
    if (newstr == str) {
        newstr = rb_str_dup(str);
    }
    else {
        RBASIC(newstr)-&gt;klass = rb_obj_class(str);
    }
    return str_encode_associate(newstr, encidx);
}</pre>
</body>
</html>
