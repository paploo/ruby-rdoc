<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>chomp! (String)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     str.chomp!(separator=$/)   =&gt; str or nil
 *  
 *  Modifies &lt;i&gt;str&lt;/i&gt; in place as described for &lt;code&gt;String#chomp&lt;/code&gt;,
 *  returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no modifications were made.
 */

static VALUE
rb_str_chomp_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    VALUE rs;
    int newline;
    char *p, *pp, *e;
    long len, rslen;

    len = RSTRING_LEN(str);
    if (len == 0) return Qnil;
    p = RSTRING_PTR(str);
    e = p + len;
    if (argc == 0) {
        rs = rb_rs;
        if (rs == rb_default_rs) {
          smart_chomp:
            str_modify_keep_cr(str);
            enc = rb_enc_get(str);
            if (rb_enc_mbminlen(enc) &gt; 1) {
                pp = rb_enc_left_char_head(p, e-rb_enc_mbminlen(enc), e, enc);
                if (rb_enc_is_newline(pp, e, enc)) {
                    e = pp;
                }
                pp = e - rb_enc_mbminlen(enc);
                if (pp &gt;= p) {
                    pp = rb_enc_left_char_head(p, pp, e, enc);
                    if (rb_enc_ascget(pp, e, 0, enc) == '\r') {
                        e = pp;
                    }
                }
                if (e == RSTRING_END(str)) {
                    return Qnil;
                }
                len = e - RSTRING_PTR(str);
                STR_SET_LEN(str, len);
            }
            else {
                if (RSTRING_PTR(str)[len-1] == '\n') {
                    STR_DEC_LEN(str);
                    if (RSTRING_LEN(str) &gt; 0 &amp;&amp;
                        RSTRING_PTR(str)[RSTRING_LEN(str)-1] == '\r') {
                        STR_DEC_LEN(str);
                    }
                }
                else if (RSTRING_PTR(str)[len-1] == '\r') {
                    STR_DEC_LEN(str);
                }
                else {
                    return Qnil;
                }
            }
            RSTRING_PTR(str)[RSTRING_LEN(str)] = '\0';
            return str;
        }
    }
    else {
        rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs);
    }
    if (NIL_P(rs)) return Qnil;
    StringValue(rs);
    rslen = RSTRING_LEN(rs);
    if (rslen == 0) {
        while (len&gt;0 &amp;&amp; p[len-1] == '\n') {
            len--;
            if (len&gt;0 &amp;&amp; p[len-1] == '\r')
                len--;
        }
        if (len &lt; RSTRING_LEN(str)) {
            str_modify_keep_cr(str);
            STR_SET_LEN(str, len);
            RSTRING_PTR(str)[len] = '\0';
            return str;
        }
        return Qnil;
    }
    if (rslen &gt; len) return Qnil;
    newline = RSTRING_PTR(rs)[rslen-1];
    if (rslen == 1 &amp;&amp; newline == '\n')
        goto smart_chomp;

    enc = rb_enc_check(str, rs);
    if (is_broken_string(rs)) {
        return Qnil;
    }
    pp = e - rslen;
    if (p[len-1] == newline &amp;&amp;
        (rslen &lt;= 1 ||
         memcmp(RSTRING_PTR(rs), pp, rslen) == 0)) {
        if (rb_enc_left_char_head(p, pp, e, enc) != pp)
            return Qnil;
        str_modify_keep_cr(str);
        STR_SET_LEN(str, RSTRING_LEN(str) - rslen);
        RSTRING_PTR(str)[RSTRING_LEN(str)] = '\0';
        return str;
    }
    return Qnil;
}</pre>
</body>
</html>
