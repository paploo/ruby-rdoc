<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>upto (String)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     str.upto(other_str, exclusive=false) {|s| block }   =&gt; str
 *  
 *  Iterates through successive values, starting at &lt;i&gt;str&lt;/i&gt; and
 *  ending at &lt;i&gt;other_str&lt;/i&gt; inclusive, passing each value in turn to
 *  the block. The &lt;code&gt;String#succ&lt;/code&gt; method is used to generate
 *  each value.  If optional second argument exclusive is omitted or is &lt;code&gt;false&lt;/code&gt;,
 *  the last value will be included; otherwise it will be excluded.
 *     
 *     &quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, ' ' }
 *     for s in &quot;a8&quot;..&quot;b6&quot;
 *       print s, ' '
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     a8 a9 b0 b1 b2 b3 b4 b5 b6
 *     a8 a9 b0 b1 b2 b3 b4 b5 b6
 */

static VALUE
rb_str_upto(int argc, VALUE *argv, VALUE beg)
{
    VALUE end, exclusive;
    VALUE current, after_end;
    ID succ;
    int n, excl;
    rb_encoding *enc;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;end, &amp;exclusive);
    RETURN_ENUMERATOR(beg, argc, argv);
    excl = RTEST(exclusive);
    CONST_ID(succ, &quot;succ&quot;);
    StringValue(end);
    enc = rb_enc_check(beg, end);
    if (RSTRING_LEN(beg) == 1 &amp;&amp; RSTRING_LEN(end) == 1 &amp;&amp;
        is_ascii_string(beg) &amp;&amp; is_ascii_string(end)) {
        char c = RSTRING_PTR(beg)[0];
        char e = RSTRING_PTR(end)[0];

        if (c &gt; e || (excl &amp;&amp; c == e)) return beg;
        for (;;) {
            rb_yield(rb_enc_str_new(&amp;c, 1, enc));
            if (!excl &amp;&amp; c == e) break;
            c++;
            if (excl &amp;&amp; c == e) break;
        }
        return beg;
    }
    n = rb_str_cmp(beg, end);
    if (n &gt; 0 || (excl &amp;&amp; n == 0)) return beg;
        
    after_end = rb_funcall(end, succ, 0, 0);
    current = beg;
    while (!rb_str_equal(current, after_end)) {
        rb_yield(current);
        if (!excl &amp;&amp; rb_str_equal(current, end)) break;
        current = rb_funcall(current, succ, 0, 0);
        StringValue(current);
        if (excl &amp;&amp; rb_str_equal(current, end)) break;
        if (RSTRING_LEN(current) &gt; RSTRING_LEN(end) || RSTRING_LEN(current) == 0)
            break;
    }

    return beg;
}</pre>
</body>
</html>
