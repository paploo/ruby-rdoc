<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>open (Kernel)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     open(path [, mode_enc [, perm]] [, opt] )                =&gt; io or nil
 *     open(path [, mode_enc [, perm]] [, opt] ) {|io| block }  =&gt; obj
 *
 *  Creates an &lt;code&gt;IO&lt;/code&gt; object connected to the given stream,
 *  file, or subprocess.
 *
 *  If &lt;i&gt;path&lt;/i&gt; does not start with a pipe character
 *  (``&lt;code&gt;|&lt;/code&gt;''), treat it as the name of a file to open using
 *  the specified mode (defaulting to ``&lt;code&gt;r&lt;/code&gt;'').
 *
 *  The mode_enc is
 *  either a string or an integer.  If it is an integer, it must be
 *  bitwise-or of open(2) flags, such as File::RDWR or File::EXCL.
 *  If it is a string, it is either &quot;mode&quot;, &quot;mode:ext_enc&quot;, or
 *  &quot;mode:ext_enc:int_enc&quot;.
 *  The mode is one of the following:
 *
 *   r: read (default)
 *   w: write
 *   a: append
 *
 *  The mode can be followed by &quot;b&quot; (means binary-mode), or &quot;+&quot;
 *  (means both reading and writing allowed) or both.
 *  If ext_enc (external encoding) is specified,
 *  read string will be tagged by the encoding in reading,
 *  and output string will be converted
 *  to the specified encoding in writing.
 *  If two encoding names,
 *  ext_enc and int_enc (external encoding and internal encoding),
 *  are specified, the read string is converted from ext_enc
 *  to int_enc then tagged with the int_enc in read mode,
 *  and in write mode, the output string will be
 *  converted from int_enc to ext_enc before writing.
 *
 *  If a file is being created, its initial permissions may be
 *  set using the integer third parameter.
 *
 *  If a block is specified, it will be invoked with the
 *  &lt;code&gt;File&lt;/code&gt; object as a parameter, and the file will be
 *  automatically closed when the block terminates. The call
 *  returns the value of the block.
 *
 *  If &lt;i&gt;path&lt;/i&gt; starts with a pipe character, a subprocess is
 *  created, connected to the caller by a pair of pipes. The returned
 *  &lt;code&gt;IO&lt;/code&gt; object may be used to write to the standard input
 *  and read from the standard output of this subprocess. If the command
 *  following the ``&lt;code&gt;|&lt;/code&gt;'' is a single minus sign, Ruby forks,
 *  and this subprocess is connected to the parent. In the subprocess,
 *  the &lt;code&gt;open&lt;/code&gt; call returns &lt;code&gt;nil&lt;/code&gt;. If the command
 *  is not ``&lt;code&gt;-&lt;/code&gt;'', the subprocess runs the command. If a
 *  block is associated with an &lt;code&gt;open(&quot;|-&quot;)&lt;/code&gt; call, that block
 *  will be run twice---once in the parent and once in the child. The
 *  block parameter will be an &lt;code&gt;IO&lt;/code&gt; object in the parent and
 *  &lt;code&gt;nil&lt;/code&gt; in the child. The parent's &lt;code&gt;IO&lt;/code&gt; object
 *  will be connected to the child's &lt;code&gt;$stdin&lt;/code&gt; and
 *  &lt;code&gt;$stdout&lt;/code&gt;. The subprocess will be terminated at the end
 *  of the block.
 *
 *     open(&quot;testfile&quot;) do |f|
 *       print f.gets
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     This is line one
 *
 *  Open a subprocess and read its output:
 *
 *     cmd = open(&quot;|date&quot;)
 *     print cmd.gets
 *     cmd.close
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Wed Apr  9 08:56:31 CDT 2003
 *
 *  Open a subprocess running the same Ruby program:
 *
 *     f = open(&quot;|-&quot;, &quot;w+&quot;)
 *     if f == nil
 *       puts &quot;in Child&quot;
 *       exit
 *     else
 *       puts &quot;Got: #{f.gets}&quot;
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Got: in Child
 *
 *  Open a subprocess using a block to receive the I/O object:
 *
 *     open(&quot;|-&quot;) do |f|
 *       if f == nil
 *         puts &quot;in Child&quot;
 *       else
 *         puts &quot;Got: #{f.gets}&quot;
 *       end
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Got: in Child
 */

static VALUE
rb_f_open(int argc, VALUE *argv)
{
    ID to_open = 0;
    int redirect = Qfalse;

    if (argc &gt;= 1) {
        CONST_ID(to_open, &quot;to_open&quot;);
        if (rb_respond_to(argv[0], to_open)) {
            redirect = Qtrue;
        }
        else {
            VALUE tmp = argv[0];
            FilePathValue(tmp);
            if (NIL_P(tmp)) {
                redirect = Qtrue;
            }
            else {
                VALUE cmd = check_pipe_command(tmp);
                if (!NIL_P(cmd)) {
                    argv[0] = cmd;
                    return rb_io_s_popen(argc, argv, rb_cIO);
                }
            }
        }
    }
    if (redirect) {
        VALUE io = rb_funcall2(argv[0], to_open, argc-1, argv+1);

        if (rb_block_given_p()) {
            return rb_ensure(rb_yield, io, io_close, io);
        }
        return io;
    }
    return rb_io_s_open(argc, argv, rb_cFile);
}</pre>
</body>
</html>
