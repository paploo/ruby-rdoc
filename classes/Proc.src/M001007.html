<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>lambda? (Proc)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   prc.lambda? =&gt; true or false
 *
 * Returns true for a Proc object which argument handling is rigid.
 * Such procs are typically generated by lambda.
 *
 * A Proc object generated by proc ignore extra arguments.
 *
 *   proc {|a,b| [a,b] }.call(1,2,3)    =&gt; [1,2]
 *
 * It provides nil for lacked arguments.
 *
 *   proc {|a,b| [a,b] }.call(1)        =&gt; [1,nil]
 *
 * It expand single-array argument.
 *
 *   proc {|a,b| [a,b] }.call([1,2])    =&gt; [1,2]
 *
 * A Proc object generated by lambda doesn't have such tricks.
 *
 *   lambda {|a,b| [a,b] }.call(1,2,3)  =&gt; ArgumentError
 *   lambda {|a,b| [a,b] }.call(1)      =&gt; ArgumentError
 *   lambda {|a,b| [a,b] }.call([1,2])  =&gt; ArgumentError
 *
 * Proc#lambda? is a predicate for the tricks.
 * It returns true if no tricks.
 *
 *   lambda {}.lambda?          =&gt; true
 *   proc {}.lambda?            =&gt; false
 *
 * Proc.new is same as proc.
 *
 *   Proc.new {}.lambda?        =&gt; false
 *
 * lambda, proc and Proc.new preserves the tricks of
 * a Proc object given by &amp; argument.
 *
 *   lambda(&amp;lambda {}).lambda?   =&gt; true
 *   proc(&amp;lambda {}).lambda?     =&gt; true
 *   Proc.new(&amp;lambda {}).lambda? =&gt; true
 *
 *   lambda(&amp;proc {}).lambda?   =&gt; false
 *   proc(&amp;proc {}).lambda?     =&gt; false
 *   Proc.new(&amp;proc {}).lambda? =&gt; false
 *
 * A Proc object generated by &amp; argument has the tricks
 *
 *   def n(&amp;b) b.lambda? end
 *   n {}                       =&gt; false
 *
 * The &amp; argument preserves the tricks if a Proc object is given
 * by &amp; argument.
 *
 *   n(&amp;lambda {})              =&gt; true
 *   n(&amp;proc {})                =&gt; false
 *   n(&amp;Proc.new {})            =&gt; false
 *
 * A Proc object converted from a method has no tricks.
 *
 *   def m() end
 *   method(:m).to_proc.lambda? =&gt; true
 *
 *   n(&amp;method(:m))             =&gt; true
 *   n(&amp;method(:m).to_proc)     =&gt; true
 *
 * define_method is treated same as method definition.
 * The defined method has no tricks.
 *
 *   class C
 *     define_method(:d) {}
 *   end
 *   C.new.e(1,2)       =&gt; ArgumentError
 *   C.new.method(:d).to_proc.lambda?   =&gt; true
 *
 * define_method always defines a method without the tricks,
 * even if a non-lambda Proc object is given.
 * This is the only exception which the tricks are not preserved.
 *
 *   class C
 *     define_method(:e, &amp;proc {})
 *   end
 *   C.new.e(1,2)       =&gt; ArgumentError
 *   C.new.method(:e).to_proc.lambda?   =&gt; true
 *
 * This exception is for a wrapper of define_method.
 * It eases defining a method defining method which defines a usual method which has no tricks.
 *
 *   class &lt;&lt; C
 *     def def2(name, &amp;body)
 *       define_method(name, &amp;body)
 *     end
 *   end
 *   class C
 *     def2(:f) {}
 *   end
 *   C.new.f(1,2)       =&gt; ArgumentError
 *
 * The wrapper, def2, defines a method which has no tricks.
 *
 */

static VALUE
proc_lambda_p(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    return proc-&gt;is_lambda ? Qtrue : Qfalse;
}</pre>
</body>
</html>
