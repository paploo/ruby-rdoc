<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>handle_special_CROSSREF (RDoc::Markup::ToHtmlCrossref)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>     <span class="ruby-comment cmt"># File lib/rdoc/markup/to_html_crossref.rb, line 99</span>
 99:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">handle_special_CROSSREF</span>(<span class="ruby-identifier">special</span>)
100:     <span class="ruby-identifier">name</span> = <span class="ruby-identifier">special</span>.<span class="ruby-identifier">text</span>
101: 
102:     <span class="ruby-comment cmt"># This ensures that words entirely consisting of lowercase letters will</span>
103:     <span class="ruby-comment cmt"># not have cross-references generated (to suppress lots of</span>
104:     <span class="ruby-comment cmt"># erroneous cross-references to &quot;new&quot; in text, for instance)</span>
105:     <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">name</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/\A[a-z]*\z/</span>
106: 
107:     <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@seen</span>[<span class="ruby-identifier">name</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@seen</span>.<span class="ruby-identifier">include?</span> <span class="ruby-identifier">name</span>
108: 
109:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">name</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value str">'#'</span> <span class="ruby-keyword kw">then</span>
110:       <span class="ruby-identifier">lookup</span> = <span class="ruby-identifier">name</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
111:       <span class="ruby-identifier">name</span> = <span class="ruby-identifier">lookup</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-ivar">@show_hash</span>
112:     <span class="ruby-keyword kw">else</span>
113:       <span class="ruby-identifier">lookup</span> = <span class="ruby-identifier">name</span>
114:     <span class="ruby-keyword kw">end</span>
115: 
116: 
117:     <span class="ruby-comment cmt"># Find class, module, or method in class or module.</span>
118:     <span class="ruby-comment cmt">#</span>
119:     <span class="ruby-comment cmt"># Do not, however, use an if/elsif/else chain to do so.  Instead, test</span>
120:     <span class="ruby-comment cmt"># each possible pattern until one matches.  The reason for this is that a</span>
121:     <span class="ruby-comment cmt"># string like &quot;YAML.txt&quot; could be the txt() class method of class YAML (in</span>
122:     <span class="ruby-comment cmt"># which case it would match the first pattern, which splits the string</span>
123:     <span class="ruby-comment cmt"># into container and method components and looks up both) or a filename</span>
124:     <span class="ruby-comment cmt"># (in which case it would match the last pattern, which just checks</span>
125:     <span class="ruby-comment cmt"># whether the string as a whole is a known symbol).</span>
126: 
127:     <span class="ruby-keyword kw">if</span> <span class="ruby-node">/#{CLASS_REGEXP_STR}[\.\#]#{METHOD_REGEXP_STR}/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">lookup</span> <span class="ruby-keyword kw">then</span>
128:       <span class="ruby-identifier">container</span> = <span class="ruby-identifier">$1</span>
129:       <span class="ruby-identifier">method</span> = <span class="ruby-identifier">$2</span>
130:       <span class="ruby-identifier">ref</span> = <span class="ruby-ivar">@context</span>.<span class="ruby-identifier">find_symbol</span> <span class="ruby-identifier">container</span>, <span class="ruby-identifier">method</span>
131:     <span class="ruby-keyword kw">end</span>
132: 
133:     <span class="ruby-identifier">ref</span> = <span class="ruby-ivar">@context</span>.<span class="ruby-identifier">find_symbol</span> <span class="ruby-identifier">lookup</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">ref</span>
134: 
135:     <span class="ruby-identifier">out</span> = <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">lookup</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^\\/</span> <span class="ruby-keyword kw">then</span>
136:             <span class="ruby-identifier">$'</span>
137:           <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">ref</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">ref</span>.<span class="ruby-identifier">document_self</span> <span class="ruby-keyword kw">then</span>
138:             <span class="ruby-node">&quot;&lt;a href=\&quot;#{ref.as_href(@from_path)}\&quot;&gt;#{name}&lt;/a&gt;&quot;</span>
139:           <span class="ruby-keyword kw">else</span>
140:             <span class="ruby-identifier">name</span>
141:           <span class="ruby-keyword kw">end</span>
142: 
143:     <span class="ruby-ivar">@seen</span>[<span class="ruby-identifier">name</span>] = <span class="ruby-identifier">out</span>
144: 
145:     <span class="ruby-identifier">out</span>
146:   <span class="ruby-keyword kw">end</span></pre>
</body>
</html>
