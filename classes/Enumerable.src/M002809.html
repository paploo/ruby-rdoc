<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>reduce (Enumerable)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     enum.inject(initial, sym) =&gt; obj
 *     enum.inject(sym)          =&gt; obj
 *     enum.inject(initial) {| memo, obj | block }  =&gt; obj
 *     enum.inject          {| memo, obj | block }  =&gt; obj
 *
 *     enum.reduce(initial, sym) =&gt; obj
 *     enum.reduce(sym)          =&gt; obj
 *     enum.reduce(initial) {| memo, obj | block }  =&gt; obj
 *     enum.reduce          {| memo, obj | block }  =&gt; obj
 *
 *  Combines all elements of &lt;i&gt;enum&lt;/i&gt; by applying a binary
 *  operation, specified by a block or a symbol that names a
 *  method or operator.
 *
 *  If you specify a block, then for each element in &lt;i&gt;enum&lt;i&gt;
 *  the block is passed an accumulator value (&lt;i&gt;memo&lt;/i&gt;) and the element.
 *  If you specify a symbol instead, then each element in the collection
 *  will be passed to the named method of &lt;i&gt;memo&lt;/i&gt;.
 *  In either case, the result becomes the new value for &lt;i&gt;memo&lt;/i&gt;.
 *  At the end of the iteration, the final value of &lt;i&gt;memo&lt;/i&gt; is the
 *  return value fo the method.
 *
 *  If you do not explicitly specify an &lt;i&gt;initial&lt;/i&gt; value for &lt;i&gt;memo&lt;/i&gt;,
 *  then uses the first element of collection is used as the initial value
 *  of &lt;i&gt;memo&lt;/i&gt;.
 *
 *  Examples:
 *
 *     # Sum some numbers
 *     (5..10).reduce(:+)                            #=&gt; 45
 *     # Same using a block and inject
 *     (5..10).inject {|sum, n| sum + n }            #=&gt; 45
 *     # Multiply some numbers
 *     (5..10).reduce(1, :*)                         #=&gt; 151200
 *     # Same using a block
 *     (5..10).inject(1) {|product, n| product * n } #=&gt; 151200
 *     # find the longest word
 *     longest = %w{ cat sheep bear }.inject do |memo,word|
 *        memo.length &gt; word.length ? memo : word
 *     end
 *     longest                                       #=&gt; &quot;sheep&quot;
 *
 */
static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];
    VALUE (*iter)(VALUE, VALUE, int, VALUE*) = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
        memo[0] = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        memo[1] = (VALUE)rb_to_id(memo[0]);
        memo[0] = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        memo[1] = (VALUE)rb_to_id(memo[1]);
        iter = inject_op_i;
        break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}</pre>
</body>
</html>
