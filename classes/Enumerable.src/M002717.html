<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>zip (Enumerable)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 *  call-seq:
 *     enum.zip(arg, ...)                   =&gt; enumerator
 *     enum.zip(arg, ...) {|arr| block }    =&gt; nil
 *
 *  Takes one element from &lt;i&gt;enum&lt;/i&gt; and merges corresponding
 *  elements from each &lt;i&gt;args&lt;/i&gt;.  This generates a sequence of
 *  &lt;em&gt;n&lt;/em&gt;-element arrays, where &lt;em&gt;n&lt;/em&gt; is one more than the
 *  count of arguments.  The length of the resulting sequence will be
 *  &lt;code&gt;enum#size&lt;/code.  If the size of any argument is less than
 *  &lt;code&gt;enum#size&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; values are supplied. If
 *  a block is given, it is invoked for each output array, otherwise
 *  an array of arrays is returned.
 *
 *     a = [ 4, 5, 6 ]
 *     b = [ 7, 8, 9 ]
 *
 *     [1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
 *     [1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
 *     a.zip([1,2],[8])       #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]
 *
 */

static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    NODE *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = Qtrue;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = Qfalse;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        CONST_ID(conv, &quot;to_enum&quot;);
        for (i=0; i&lt;argc; i++) {
            argv[i] = rb_funcall(argv[i], conv, 1, ID2SYM(id_each));
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }
    /* use NODE_DOT2 as memo(v, v, -) */
    memo = rb_node_newnode(NODE_DOT2, result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</pre>
</body>
</html>
