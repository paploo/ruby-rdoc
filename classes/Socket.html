<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: Socket [RDoc Documentation]</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }<\/style>" )

  // ]]>
  </script>

</head>
<body>


    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">Socket</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>


                <a href="../files/lib/ipaddr_rb.html">

                lib/ipaddr.rb

                </a>


        <br />


                <a href="../files/ext/socket/socket_c.html">

                ext/socket/socket.c

                </a>


        <br />

            </td>
        </tr>


        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>

                <a href="Object.html">

                Object

               </a>

            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">

  <div id="contextContent">

    <div id="description">
      <p>
<a href="Class.html">Class</a> <tt>Socket</tt> provides access to the
underlying operating system socket implementations. It can be used to
provide more operating system specific functionality than the
protocol-specific socket classes but at the expense of greater complexity.
In particular, the class handles addresses using <tt>struct</tt> sockaddr
structures packed into Ruby strings, which can be a joy to manipulate.
</p>
<h3><a href="Exception.html">Exception</a> Handling</h3>
<p>
Ruby&#8217;s implementation of <tt>Socket</tt> causes an exception to be
raised based on the error generated by the system dependent implementation.
This is why the methods are documented in a way that isolate Unix-based
system exceptions from Windows based exceptions. If more information on
particular exception is needed please refer to the Unix manual pages or the
Windows WinSock reference.
</p>
<h3>Documentation by</h3>
<ul>
<li>Zach Dennis

</li>
<li>Sam Roberts

</li>
<li><em>Programming Ruby</em> from The Pragmatic Bookshelf.

</li>
</ul>
<p>
Much material in this documentation is taken with permission from
<em>Programming Ruby</em> from The Pragmatic Bookshelf.
</p>

    </div>

   </div>


    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">

        <a href="#M001666">accept_nonblock</a>&nbsp;&nbsp;

        <a href="#M001664">bind</a>&nbsp;&nbsp;

        <a href="#M001662">connect</a>&nbsp;&nbsp;

        <a href="#M001663">connect_nonblock</a>&nbsp;&nbsp;

        <a href="#M001665">listen</a>&nbsp;&nbsp;

        <a href="#M001668">recvfrom</a>&nbsp;&nbsp;

        <a href="#M001669">recvfrom_nonblock</a>&nbsp;&nbsp;

        <a href="#M001667">sysaccept</a>&nbsp;&nbsp;

      </div>
    </div>

  </div>

    <!-- if includes -->

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Module <a href="Socket/Constants.html" class="link">Socket::Constants</a><br />

    </div>

    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">

        <tr class="top-aligned-row context-row">
          <td class="context-item-name">AF_INET6</td>
          <td>=</td>
          <td class="context-item-value">Object.new</td>

        </tr>

        </table>
      </div>
    </div>




    <!-- if method_list -->

    <div id="methods">

      <h3 class="section-bar">Public Instance methods</h3>


      <div id="method-M001666" class="method-detail">
        <a name="M001666"></a>

        <div class="method-heading">

          <a href="Socket.src/M001666.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001666.html');return false;">

          <span class="method-name">socket.accept_nonblock => [client_socket, client_sockaddr]<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Accepts an incoming connection using accept(2) after O_NONBLOCK is set for
the underlying file descriptor. It returns an array containg the accpeted
socket for the incoming connection, <em>client_socket</em>, and a string
that contains the <tt>struct</tt> sockaddr information about the caller,
<em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     begin # emulate blocking accept
       client_socket, client_sockaddr = socket.accept_nonblock
     rescue Errno::EAGAIN, Errno::EWOULDBLOCK, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
       IO.select([socket])
       retry
     end
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to Socket#accept for the exceptions that may be thrown if the call to
<em><a href="Socket.html#M001666">accept_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M001666">Socket#accept_nonblock</a> may raise any
error corresponding to accept(2) failure, including Errno::EWOULDBLOCK.
</p>
<h3>See</h3>
<ul>
<li>Socket#accept

</li>
</ul>

        </div>
      </div>


      <div id="method-M001664" class="method-detail">
        <a name="M001664"></a>

        <div class="method-heading">

          <a href="Socket.src/M001664.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001664.html');return false;">

          <span class="method-name">socket.bind(server_sockaddr) => 0<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Binds to the given <tt>struct</tt> sockaddr.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>bind</em> fails:
</p>
<ul>
<li>Errno::EACCES - the specified <em>sockaddr</em> is protected and the
current user does not have permission to bind to it

</li>
<li>Errno::EADDRINUSE - the specified <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> isnot a valid address
for the family of the calling <tt>socket</tt>

</li>
<li>Errno::EBADF - the <em>sockaddr</em> specified is not a valid file
descriptor

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> argument cannot be accessed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address, and the
protocol does not support binding to the new <em>sockaddr</em> or the
<tt>socket</tt> has been shut down.

</li>
<li>Errno::EINVAL - the address length is not a valid length for the address
family

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the socket type of the <tt>socket</tt> does not support
binding to an address

</li>
</ul>
<p>
On unix-based based systems if the address family of the calling
<tt>socket</tt> is Socket::AF_UNIX the follow exceptions may be raised if
the call to <em>bind</em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EDESTADDRREQ - the <em>sockaddr</em> argument is a null pointer

</li>
<li>Errno::EISDIR - same as Errno::EDESTADDRREQ

</li>
<li>Errno::EIO - an i/o error occurred

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
<li>Errno::EROFS - the name would reside on a read only filesystem

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>bind</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN&#8212; the network is down

</li>
<li>Errno::EACCES - the attempt to connect the datagram socket to the broadcast
address failed

</li>
<li>Errno::EADDRINUSE - the socket&#8217;s local address is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified address is not a valid address for
this computer

</li>
<li>Errno::EFAULT - the socket&#8217;s internal address or address length
parameter is too small or is not a valid part of the user space addressed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
</ul>
<h3>See</h3>
<ul>
<li>bind manual pages on unix-based systems

</li>
<li>bind function in Microsoft&#8217;s Winsock functions reference

</li>
</ul>

        </div>
      </div>


      <div id="method-M001662" class="method-detail">
        <a name="M001662"></a>

        <div class="method-heading">

          <a href="Socket.src/M001662.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001662.html');return false;">

          <span class="method-name">socket.connect(server_sockaddr) => 0<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>.
Returns 0 if successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
     socket.connect( sockaddr )
     socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
     results = socket.read
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based systems the following system exceptions may be raised if the
call to <em>connect</em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EADDRINUSE - the <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid
address for the address family of the specified <tt>socket</tt>

</li>
<li>Errno::EALREADY - a connection is already in progress for the specified
socket

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li><a href="Errno/ECONNRESET.html">Errno::ECONNRESET</a> - the remote host
reset the connection request

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> cannot be accessed

</li>
<li>Errno::EHOSTUNREACH - the destination host cannot be reached (probably
because the host is down or a remote router cannot reach it)

</li>
<li>Errno::EINPROGRESS - the O_NONBLOCK is set for the <tt>socket</tt> and the
connection cnanot be immediately established; the connection will be
established asynchronously

</li>
<li>Errno::EINTR - the attempt to establish the connection was interrupted by
delivery of a signal that was caught; the connection will be established
asynchronously

</li>
<li>Errno::EISCONN - the specified <tt>socket</tt> is already connected

</li>
<li>Errno::EINVAL - the address length used for the <em>sockaddr</em> is not a
valid length for the address family or there is an invalid family in
<em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENETDOWN - the local interface used to reach the destination is down

</li>
<li>Errno::ENETUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the calling <tt>socket</tt> is listening and cannot be
connected

</li>
<li>Errno::EPROTOTYPE - the <em>sockaddr</em> has a different type than the
socket bound to the specified peer address

</li>
<li>Errno::ETIMEDOUT - the attempt to connect time out before a connection was
made.

</li>
</ul>
<p>
On unix-based systems if the address family of the calling <tt>socket</tt>
is AF_UNIX the follow exceptions may be raised if the call to
<em>connect</em> fails:
</p>
<ul>
<li>Errno::EIO - an i/o error occured while reading from or writing to the file
system

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>connect</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8217;s local address is already in use

</li>
<li>Errno::EINTR - the socket was cancelled

</li>
<li>Errno::EINPROGRESS - a blocking socket is in progress or the service
provider is still processing a callback function. Or a nonblocking connect
call is in progress on the <tt>socket</tt>.

</li>
<li>Errno::EALREADY - see Errno::EINVAL

</li>
<li>Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
ADDR_ANY TODO check ADDRANY TO INADDR_ANY

</li>
<li>Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
with this <tt>socket</tt>

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li>Errno::EFAULT - the socket&#8217;s internal address or address length
parameter is too small or is not a valid part of the user space address

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is a listening socket

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::ENETUNREACH - the network cannot be reached from this host at this
time

</li>
<li>Errno::EHOSTUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::ETIMEDOUT - the attempt to connect time out before a connection was
made.

</li>
<li>Errno::EWOULDBLOCK - the socket is marked as nonblocking and the connection
cannot be completed immediately

</li>
<li>Errno::EACCES - the attempt to connect the datagram socket to the broadcast
address failed

</li>
</ul>
<h3>See</h3>
<ul>
<li>connect manual pages on unix-based systems

</li>
<li>connect function in Microsoft&#8217;s Winsock functions reference

</li>
</ul>

        </div>
      </div>


      <div id="method-M001663" class="method-detail">
        <a name="M001663"></a>

        <div class="method-heading">

          <a href="Socket.src/M001663.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001663.html');return false;">

          <span class="method-name">socket.connect_nonblock(server_sockaddr) => 0<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>
after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if
successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(80, 'www.google.com')
     begin # emulate blocking connect
       socket.connect_nonblock(sockaddr)
     rescue Errno::EINPROGRESS
       IO.select(nil, [socket])
       begin
         socket.connect_nonblock(sockaddr)
       rescue Errno::EISCONN
       end
     end
     socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
     results = socket.read
</pre>
<p>
Refer to <a href="Socket.html#M001662">Socket#connect</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M001663">connect_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M001663">Socket#connect_nonblock</a> may raise any
error corresponding to connect(2) failure, including Errno::EINPROGRESS.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001662">Socket#connect</a>

</li>
</ul>

        </div>
      </div>


      <div id="method-M001665" class="method-detail">
        <a name="M001665"></a>

        <div class="method-heading">

          <a href="Socket.src/M001665.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001665.html');return false;">

          <span class="method-name">socket.listen( int ) => 0<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Listens for connections, using the specified <tt>int</tt> as the backlog. A
call to <em>listen</em> only applies if the <tt>socket</tt> is of type
SOCK_STREAM or SOCK_SEQPACKET.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>backlog</tt> - the maximum length of the queue for pending connections.

</li>
</ul>
<h3>Example 1</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
</pre>
<h3>Example 2 (listening on an arbitary port, unix-based systems only):</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     socket.listen( 1 )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix based systems the above will work because a new <tt>sockaddr</tt>
struct is created on the address ADDR_ANY, for an arbitrary port number as
handed off by the kernel. It will not work on Windows, because Windows
requires that the <tt>socket</tt> is bound by calling <em>bind</em> before
it can <em>listen</em>.
</p>
<p>
If the <em>backlog</em> amount exceeds the implementation-dependent maximum
queue length, the implementation&#8217;s maximum queue length will be used.
</p>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>listen</em> fails:
</p>
<ul>
<li>Errno::EBADF - the <em>socket</em> argument is not a valid file descriptor

</li>
<li>Errno::EDESTADDRREQ - the <em>socket</em> is not bound to a local address,
and the protocol does not support listening on an unbound socket

</li>
<li>Errno::EINVAL - the <em>socket</em> is already connected

</li>
<li>Errno::ENOTSOCK - the <em>socket</em> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the <em>socket</em> protocol does not support listen

</li>
<li>Errno::EACCES - the calling process does not have approriate privileges

</li>
<li>Errno::EINVAL - the <em>socket</em> has been shut down

</li>
<li>Errno::ENOBUFS - insufficient resources are available in the system to
complete the call

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>listen</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8217;s local address is already in use.
This usually occurs during the execution of <em>bind</em> but could be
delayed if the call to <em>bind</em> was to a partially wildcard address
(involving ADDR_ANY) and if a specific address needs to be commmitted at
the time of the call to <em>listen</em>

</li>
<li>Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
service provider is still processing a callback function

</li>
<li>Errno::EINVAL - the <tt>socket</tt> has not been bound with a call to
<em>bind</em>.

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::EMFILE - no more socket descriptors are available

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOC - <tt>socket</tt> is not a socket

</li>
<li>Errno::EOPNOTSUPP - the referenced <tt>socket</tt> is not a type that
supports the <em>listen</em> method

</li>
</ul>
<h3>See</h3>
<ul>
<li>listen manual pages on unix-based systems

</li>
<li>listen function in Microsoft&#8217;s Winsock functions reference

</li>
</ul>

        </div>
      </div>


      <div id="method-M001668" class="method-detail">
        <a name="M001668"></a>

        <div class="method-heading">

          <a href="Socket.src/M001668.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001668.html');return false;">

          <span class="method-name">socket.recvfrom(maxlen) => [mesg, sender_sockaddr]<br />
socket.recvfrom(maxlen, flags) => [mesg, sender_sockaddr]<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt>. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_sockaddr</em>, contains protocol-specific information on the
sender.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     data = client.recvfrom( 20 )[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>recvfrom</em> fails:
</p>
<ul>
<li>Errno::EAGAIN - the <tt>socket</tt> file descriptor is marked as O_NONBLOCK
and no data is waiting to be received; or MSG_OOB is set and no out-of-band
data is available and either the <tt>socket</tt> file descriptor is marked
as O_NONBLOCK or the <tt>socket</tt> does not support blocking to wait for
out-of-band-data

</li>
<li>Errno::EWOULDBLOCK - see Errno::EAGAIN

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li><a href="Errno/ECONNRESET.html">Errno::ECONNRESET</a> - a connection was
forcibly closed by a peer

</li>
<li>Errno::EFAULT - the socket&#8217;s internal buffer, address or address
length cannot be accessed or written

</li>
<li>Errno::EINTR - a signal interupted <em>recvfrom</em> before any data was
available

</li>
<li>Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
available

</li>
<li>Errno::EIO - an i/o error occurred while reading from or writing to the
filesystem

</li>
<li>Errno::ENOBUFS - insufficient resources were available in the system to
perform the operation

</li>
<li>Errno::ENOMEM - insufficient memory was available to fulfill the request

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
is not connected

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the specified flags are not supported for this socket
type

</li>
<li>Errno::ETIMEDOUT - the connection timed out during connection establishment
or due to a transmission timeout on an active connection

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>recvfrom</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EFAULT - the internal buffer and from parameters on <tt>socket</tt>
are not part of the user address space, or the internal fromlen parameter
is too small to accomodate the peer address

</li>
<li>Errno::EINTR - the (blocking) call was cancelled by an internal call to the
WinSock function WSACancelBlockingCall

</li>
<li>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function

</li>
<li>Errno::EINVAL - <tt>socket</tt> has not been bound with a call to
<em>bind</em>, or an unknown flag was specified, or MSG_OOB was specified
for a socket with SO_OOBINLINE enabled, or (for byte stream-style sockets
only) the internal len parameter on <tt>socket</tt> was zero or negative

</li>
<li>Errno::EISCONN - <tt>socket</tt> is already connected. The call to
<em>recvfrom</em> is not permitted with a connected socket on a socket that
is connetion oriented or connectionless.

</li>
<li>Errno::ENETRESET - the connection has been broken due to the keep-alive
activity detecting a failure while the operation was in progress.

</li>
<li>Errno::EOPNOTSUPP - MSG_OOB was specified, but <tt>socket</tt> is not
stream-style such as type SOCK_STREAM. OOB data is not supported in the
communication domain associated with <tt>socket</tt>, or <tt>socket</tt> is
unidirectional and supports only send operations

</li>
<li>Errno::ESHUTDOWN - <tt>socket</tt> has been shutdown. It is not possible to
call <em>recvfrom</em> on a socket after <em>shutdown</em> has been
invoked.

</li>
<li>Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and a call to
<em>recvfrom</em> would block.

</li>
<li>Errno::EMSGSIZE - the message was too large to fit into the specified
buffer and was truncated.

</li>
<li>Errno::ETIMEDOUT - the connection has been dropped, because of a network
failure or because the system on the other end went down without notice

</li>
<li><a href="Errno/ECONNRESET.html">Errno::ECONNRESET</a> - the virtual circuit
was reset by the remote side executing a hard or abortive close. The
application should close the socket; it is no longer usable. On a
UDP-datagram socket this error indicates a previous send operation resulted
in an ICMP Port Unreachable message.

</li>
</ul>

        </div>
      </div>


      <div id="method-M001669" class="method-detail">
        <a name="M001669"></a>

        <div class="method-heading">

          <a href="Socket.src/M001669.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001669.html');return false;">

          <span class="method-name">socket.recvfrom_nonblock(maxlen) => [mesg, sender_sockaddr]<br />
socket.recvfrom_nonblock(maxlen, flags) => [mesg, sender_sockaddr]<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using recvfrom(2)
after O_NONBLOCK is set for the underlying file descriptor. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_sockaddr</em>, contains protocol-specific information on the
sender.
</p>
<p>
When recvfrom(2) returns 0, <a
href="Socket.html#M001669">Socket#recvfrom_nonblock</a> returns an empty
string as data. The meaning depends on the socket: EOF on TCP, empty packet
on UDP, etc.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     client, client_sockaddr = socket.accept
     begin # emulate blocking recvfrom
       pair = client.recvfrom_nonblock(20)
     rescue Errno::EAGAIN, Errno::EWOULDBLOCK
       IO.select([client])
       retry
     end
     data = pair[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M001668">Socket#recvfrom</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M001669">recvfrom_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M001669">Socket#recvfrom_nonblock</a> may raise any
error corresponding to recvfrom(2) failure, including Errno::EWOULDBLOCK.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M001668">Socket#recvfrom</a>

</li>
</ul>

        </div>
      </div>


      <div id="method-M001667" class="method-detail">
        <a name="M001667"></a>

        <div class="method-heading">

          <a href="Socket.src/M001667.html" target="Code" class="method-signature"
            onclick="popupCode('Socket.src/M001667.html');return false;">

          <span class="method-name">socket.sysaccept => [client_socket_fd, client_sockaddr]<br />
</span>

          </a>

        </div>

        <div class="method-description">

          <p>
Accepts an incoming connection returnings an array containg the (integer)
file descriptor for the incoming connection, <em>client_socket_fd</em>, and
a string that contains the <tt>struct</tt> sockaddr information about the
caller, <em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client_fd, client_sockaddr = socket.sysaccept
     client_socket = Socket.for_fd( client_fd )
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to Socket#accept for the exceptions that may be thrown if the call to
<em>sysaccept</em> fails.
</p>
<h3>See</h3>
<ul>
<li>Socket#accept

</li>
</ul>

        </div>
      </div>



    </div>




  </div>

<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
